"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* harmony import */ var jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jotai/vanilla/internals */ \"(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useStore(options) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n}\nfunction Provider({ children, store }) {\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (store) {\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n            value: store\n        }, children);\n    }\n    if (storeRef.current === null) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        // TODO: If this is not a false positive, consider using useState instead of useRef like https://github.com/pmndrs/jotai/pull/2771\n        // eslint-disable-next-line react-hooks/refs\n        value: storeRef.current\n    }, children);\n}\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise)=>{\n    if (!promise.status) {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n    }\n};\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || // A shim for older React versions\n((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        attachPromiseStatus(promise);\n        throw promise;\n    }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, getValue)=>{\n    let continuablePromise = continuablePromiseMap.get(promise);\n    if (!continuablePromise) {\n        continuablePromise = new Promise((resolve, reject)=>{\n            let curr = promise;\n            const onFulfilled = (me)=>(v)=>{\n                    if (curr === me) {\n                        resolve(v);\n                    }\n                };\n            const onRejected = (me)=>(e)=>{\n                    if (curr === me) {\n                        reject(e);\n                    }\n                };\n            const onAbort = ()=>{\n                try {\n                    const nextValue = getValue();\n                    if (isPromiseLike(nextValue)) {\n                        continuablePromiseMap.set(nextValue, continuablePromise);\n                        curr = nextValue;\n                        nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n                        (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_registerAbortHandler)(nextValue, onAbort);\n                    } else {\n                        resolve(nextValue);\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            };\n            promise.then(onFulfilled(promise), onRejected(promise));\n            (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_2__.INTERNAL_registerAbortHandler)(promise, onAbort);\n        });\n        continuablePromiseMap.set(promise, continuablePromise);\n    }\n    return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n    const { delay, unstable_promiseStatus: promiseStatus = !react__WEBPACK_IMPORTED_MODULE_0__.use } = options || {};\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (promiseStatus) {\n                try {\n                    const value2 = store.get(atom);\n                    if (isPromiseLike(value2)) {\n                        attachPromiseStatus(createContinuablePromise(value2, ()=>store.get(atom)));\n                    }\n                } catch (e) {}\n            }\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay,\n        promiseStatus\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    if (isPromiseLike(value)) {\n        const promise = createContinuablePromise(value, ()=>store.get(atom));\n        if (promiseStatus) {\n            attachPromiseStatus(promise);\n        }\n        return use(promise);\n    }\n    return value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt1R0FDbUk7QUFDdEU7QUFDVztBQUV4RSxNQUFNWSw2QkFBZVgsb0RBQWFBLENBQ2hDLEtBQUs7QUFFUCxTQUFTWSxTQUFTQyxPQUFPO0lBQ3ZCLE1BQU1DLFFBQVFiLGlEQUFVQSxDQUFDVTtJQUN6QixPQUFPLENBQUNFLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFDLEtBQUssS0FBS0EsU0FBU04sOERBQWVBO0FBQy9FO0FBQ0EsU0FBU08sU0FBUyxFQUNoQkMsUUFBUSxFQUNSRixLQUFLLEVBQ047SUFDQyxNQUFNRyxXQUFXZiw2Q0FBTUEsQ0FBQztJQUN4QixJQUFJWSxPQUFPO1FBQ1QscUJBQU9YLG9EQUFhQSxDQUFDUSxhQUFhSSxRQUFRLEVBQUU7WUFBRUcsT0FBT0o7UUFBTSxHQUFHRTtJQUNoRTtJQUNBLElBQUlDLFNBQVNFLE9BQU8sS0FBSyxNQUFNO1FBQzdCRixTQUFTRSxPQUFPLEdBQUdWLDBEQUFXQTtJQUNoQztJQUNBLHFCQUFPTixvREFBYUEsQ0FDbEJRLGFBQWFJLFFBQVEsRUFDckI7UUFDRSxrSUFBa0k7UUFDbEksNENBQTRDO1FBQzVDRyxPQUFPRCxTQUFTRSxPQUFPO0lBQ3pCLEdBQ0FIO0FBRUo7QUFFQSxNQUFNSSxnQkFBZ0IsQ0FBQ0MsSUFBTSxPQUFRQSxDQUFBQSxLQUFLLE9BQU8sS0FBSyxJQUFJQSxFQUFFQyxJQUFJLE1BQU07QUFDdEUsTUFBTUMsc0JBQXNCLENBQUNDO0lBQzNCLElBQUksQ0FBQ0EsUUFBUUMsTUFBTSxFQUFFO1FBQ25CRCxRQUFRQyxNQUFNLEdBQUc7UUFDakJELFFBQVFGLElBQUksQ0FDVixDQUFDSTtZQUNDRixRQUFRQyxNQUFNLEdBQUc7WUFDakJELFFBQVFOLEtBQUssR0FBR1E7UUFDbEIsR0FDQSxDQUFDQztZQUNDSCxRQUFRQyxNQUFNLEdBQUc7WUFDakJELFFBQVFJLE1BQU0sR0FB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NEIsUUFBUSxJQUFNOUMsTUFBTXFCLEdBQUcsQ0FBQ1k7b0JBRXJEO2dCQUNGLEVBQUUsT0FBT3BCLEdBQUcsQ0FDWjtZQUNGO1lBQ0EsSUFBSSxPQUFPcUIsVUFBVSxVQUFVO2dCQUM3QmEsV0FBV1AsVUFBVU47Z0JBQ3JCO1lBQ0Y7WUFDQU07UUFDRjtRQUNBQTtRQUNBLE9BQU9JO0lBQ1QsR0FBRztRQUFDNUM7UUFBT2lDO1FBQU1DO1FBQU9FO0tBQWM7SUFDdEM1QyxvREFBYUEsQ0FBQ1k7SUFDZCxJQUFJRSxjQUFjRixRQUFRO1FBQ3hCLE1BQU1NLFVBQVVRLHlCQUF5QmQsT0FBTyxJQUFNSixNQUFNcUIsR0FBRyxDQUFDWTtRQUNoRSxJQUFJRyxlQUFlO1lBQ2pCM0Isb0JBQW9CQztRQUN0QjtRQUNBLE9BQU9LLElBQUlMO0lBQ2I7SUFDQSxPQUFPTjtBQUNUO0FBRUEsU0FBUzRDLFdBQVdmLElBQUksRUFBRWxDLE9BQU87SUFDL0IsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTWtELFVBQVV4RCxrREFBV0EsQ0FDekIsQ0FBQyxHQUFHeUQ7UUFDRixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGdCQUFnQixDQUFFLFlBQVdqQixJQUFHLEdBQUk7WUFDNUYsTUFBTSxJQUFJb0IsTUFBTTtRQUNsQjtRQUNBLE9BQU9yRCxNQUFNK0IsR0FBRyxDQUFDRSxTQUFTaUI7SUFDNUIsR0FDQTtRQUFDbEQ7UUFBT2lDO0tBQUs7SUFFZixPQUFPZ0I7QUFDVDtBQUVBLFNBQVNLLFFBQVFyQixJQUFJLEVBQUVsQyxPQUFPO0lBQzVCLE9BQU87UUFDTGlDLGFBQWFDLE1BQU1sQztRQUNuQix1RUFBdUU7UUFDdkVpRCxXQUFXZixNQUFNbEM7S0FDbEI7QUFDSDtBQUVpRSIsInNvdXJjZXMiOlsid2VicGFjazovL3RodW1ibmFpbC1kZXNpZ24vLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcz9hYzMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZHVjZXIsIHVzZUVmZmVjdCwgdXNlRGVidWdWYWx1ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXREZWZhdWx0U3RvcmUsIGNyZWF0ZVN0b3JlIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XG5pbXBvcnQgeyBJTlRFUk5BTF9yZWdpc3RlckFib3J0SGFuZGxlciB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEvaW50ZXJuYWxzJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdm9pZCAwXG4pO1xuZnVuY3Rpb24gdXNlU3RvcmUob3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIHN0b3JlXG59KSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlUmVmKG51bGwpO1xuICBpZiAoc3RvcmUpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTdG9yZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0b3JlIH0sIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoc3RvcmVSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIFN0b3JlQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIG5vdCBhIGZhbHNlIHBvc2l0aXZlLCBjb25zaWRlciB1c2luZyB1c2VTdGF0ZSBpbnN0ZWFkIG9mIHVzZVJlZiBsaWtlIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvcHVsbC8yNzcxXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcmVmc1xuICAgICAgdmFsdWU6IHN0b3JlUmVmLmN1cnJlbnRcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCkgPT4gdHlwZW9mICh4ID09IG51bGwgPyB2b2lkIDAgOiB4LnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBhdHRhY2hQcm9taXNlU3RhdHVzID0gKHByb21pc2UpID0+IHtcbiAgaWYgKCFwcm9taXNlLnN0YXR1cykge1xuICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5jb25zdCB1c2UgPSBSZWFjdC51c2UgfHwgLy8gQSBzaGltIGZvciBvbGRlciBSZWFjdCB2ZXJzaW9uc1xuKChwcm9taXNlKSA9PiB7XG4gIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIGF0dGFjaFByb21pc2VTdGF0dXMocHJvbWlzZSk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5jb25zdCBjb250aW51YWJsZVByb21pc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGNyZWF0ZUNvbnRpbnVhYmxlUHJvbWlzZSA9IChwcm9taXNlLCBnZXRWYWx1ZSkgPT4ge1xuICBsZXQgY29udGludWFibGVQcm9taXNlID0gY29udGludWFibGVQcm9taXNlTWFwLmdldChwcm9taXNlKTtcbiAgaWYgKCFjb250aW51YWJsZVByb21pc2UpIHtcbiAgICBjb250aW51YWJsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgY3VyciA9IHByb21pc2U7XG4gICAgICBjb25zdCBvbkZ1bGZpbGxlZCA9IChtZSkgPT4gKHYpID0+IHtcbiAgICAgICAgaWYgKGN1cnIgPT09IG1lKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSAobWUpID0+IChlKSA9PiB7XG4gICAgICAgIGlmIChjdXJyID09PSBtZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gZ2V0VmFsdWUoKTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51YWJsZVByb21pc2VNYXAuc2V0KG5leHRWYWx1ZSwgY29udGludWFibGVQcm9taXNlKTtcbiAgICAgICAgICAgIGN1cnIgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICBuZXh0VmFsdWUudGhlbihvbkZ1bGZpbGxlZChuZXh0VmFsdWUpLCBvblJlamVjdGVkKG5leHRWYWx1ZSkpO1xuICAgICAgICAgICAgSU5URVJOQUxfcmVnaXN0ZXJBYm9ydEhhbmRsZXIobmV4dFZhbHVlLCBvbkFib3J0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShuZXh0VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHByb21pc2UudGhlbihvbkZ1bGZpbGxlZChwcm9taXNlKSwgb25SZWplY3RlZChwcm9taXNlKSk7XG4gICAgICBJTlRFUk5BTF9yZWdpc3RlckFib3J0SGFuZGxlcihwcm9taXNlLCBvbkFib3J0KTtcbiAgICB9KTtcbiAgICBjb250aW51YWJsZVByb21pc2VNYXAuc2V0KHByb21pc2UsIGNvbnRpbnVhYmxlUHJvbWlzZSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRpbnVhYmxlUHJvbWlzZTtcbn07XG5mdW5jdGlvbiB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCB7IGRlbGF5LCB1bnN0YWJsZV9wcm9taXNlU3RhdHVzOiBwcm9taXNlU3RhdHVzID0gIVJlYWN0LnVzZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3QgW1t2YWx1ZUZyb21SZWR1Y2VyLCBzdG9yZUZyb21SZWR1Y2VyLCBhdG9tRnJvbVJlZHVjZXJdLCByZXJlbmRlcl0gPSB1c2VSZWR1Y2VyKFxuICAgIChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICBpZiAoT2JqZWN0LmlzKHByZXZbMF0sIG5leHRWYWx1ZSkgJiYgcHJldlsxXSA9PT0gc3RvcmUgJiYgcHJldlsyXSA9PT0gYXRvbSkge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV4dFZhbHVlLCBzdG9yZSwgYXRvbV07XG4gICAgfSxcbiAgICB2b2lkIDAsXG4gICAgKCkgPT4gW3N0b3JlLmdldChhdG9tKSwgc3RvcmUsIGF0b21dXG4gICk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRnJvbVJlZHVjZXI7XG4gIGlmIChzdG9yZUZyb21SZWR1Y2VyICE9PSBzdG9yZSB8fCBhdG9tRnJvbVJlZHVjZXIgIT09IGF0b20pIHtcbiAgICByZXJlbmRlcigpO1xuICAgIHZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICB9XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWIoYXRvbSwgKCkgPT4ge1xuICAgICAgaWYgKHByb21pc2VTdGF0dXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWUyKSkge1xuICAgICAgICAgICAgYXR0YWNoUHJvbWlzZVN0YXR1cyhcbiAgICAgICAgICAgICAgY3JlYXRlQ29udGludWFibGVQcm9taXNlKHZhbHVlMiwgKCkgPT4gc3RvcmUuZ2V0KGF0b20pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzZXRUaW1lb3V0KHJlcmVuZGVyLCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgfSk7XG4gICAgcmVyZW5kZXIoKTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH0sIFtzdG9yZSwgYXRvbSwgZGVsYXksIHByb21pc2VTdGF0dXNdKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlKSkge1xuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVDb250aW51YWJsZVByb21pc2UodmFsdWUsICgpID0+IHN0b3JlLmdldChhdG9tKSk7XG4gICAgaWYgKHByb21pc2VTdGF0dXMpIHtcbiAgICAgIGF0dGFjaFByb21pc2VTdGF0dXMocHJvbWlzZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2UocHJvbWlzZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3Qgc2V0QXRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcIndyaXRlXCIgaW4gYXRvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHdyaXRhYmxlIGF0b21cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmUuc2V0KGF0b20sIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgW3N0b3JlLCBhdG9tXVxuICApO1xuICByZXR1cm4gc2V0QXRvbTtcbn1cblxuZnVuY3Rpb24gdXNlQXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpLFxuICAgIC8vIFdlIGRvIHdyb25nIHR5cGUgYXNzZXJ0aW9uIGhlcmUsIHdoaWNoIHJlc3VsdHMgaW4gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKVxuICBdO1xufVxuXG5leHBvcnQgeyBQcm92aWRlciwgdXNlQXRvbSwgdXNlQXRvbVZhbHVlLCB1c2VTZXRBdG9tLCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJ1c2VDYWxsYmFjayIsImdldERlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiSU5URVJOQUxfcmVnaXN0ZXJBYm9ydEhhbmRsZXIiLCJTdG9yZUNvbnRleHQiLCJ1c2VTdG9yZSIsIm9wdGlvbnMiLCJzdG9yZSIsIlByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdG9yZVJlZiIsInZhbHVlIiwiY3VycmVudCIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsImF0dGFjaFByb21pc2VTdGF0dXMiLCJwcm9taXNlIiwic3RhdHVzIiwidiIsImUiLCJyZWFzb24iLCJ1c2UiLCJjb250aW51YWJsZVByb21pc2VNYXAiLCJXZWFrTWFwIiwiY3JlYXRlQ29udGludWFibGVQcm9taXNlIiwiZ2V0VmFsdWUiLCJjb250aW51YWJsZVByb21pc2UiLCJnZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImN1cnIiLCJvbkZ1bGZpbGxlZCIsIm1lIiwib25SZWplY3RlZCIsIm9uQWJvcnQiLCJuZXh0VmFsdWUiLCJzZXQiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwiZGVsYXkiLCJ1bnN0YWJsZV9wcm9taXNlU3RhdHVzIiwicHJvbWlzZVN0YXR1cyIsInZhbHVlRnJvbVJlZHVjZXIiLCJzdG9yZUZyb21SZWR1Y2VyIiwiYXRvbUZyb21SZWR1Y2VyIiwicmVyZW5kZXIiLCJwcmV2IiwiT2JqZWN0IiwiaXMiLCJ1bnN1YiIsInN1YiIsInZhbHVlMiIsInNldFRpbWVvdXQiLCJ1c2VTZXRBdG9tIiwic2V0QXRvbSIsImFyZ3MiLCJlbnYiLCJNT0RFIiwiRXJyb3IiLCJ1c2VBdG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_overrideCreateStore: () => (/* binding */ INTERNAL_overrideCreateStore),\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\n/* harmony import */ var jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jotai/vanilla/internals */ \"(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs\");\n\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString () {\n            return ( false ? 0 : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n        }\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = defaultRead;\n        config.write = defaultWrite;\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nfunction defaultRead(get) {\n    return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n    return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nlet overiddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n    overiddenCreateStore = fn(overiddenCreateStore);\n}\nfunction createStore() {\n    if (overiddenCreateStore) {\n        return overiddenCreateStore();\n    }\n    return (0,jotai_vanilla_internals__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_buildStoreRev2)();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n    if (!defaultStore) {\n        defaultStore = createStore();\n        if (( false ? 0 : void 0) !== \"production\") {\n            globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n            if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n                console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n            }\n        }\n    }\n    return defaultStore;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtFO0FBRWxFLElBQUlDLFdBQVc7QUFDZixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLEtBQUs7SUFDdkIsTUFBTUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFSixTQUFTLENBQUM7SUFDL0IsTUFBTUssU0FBUztRQUNiQztZQUNFLE9BQU8sQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLElBQUksQ0FBQ0csVUFBVSxHQUFHTCxNQUFNLE1BQU0sSUFBSSxDQUFDSyxVQUFVLEdBQUdMO1FBQy9IO0lBQ0Y7SUFDQSxJQUFJLE9BQU9GLFNBQVMsWUFBWTtRQUM5QkcsT0FBT0gsSUFBSSxHQUFHQTtJQUNoQixPQUFPO1FBQ0xHLE9BQU9LLElBQUksR0FBR1I7UUFDZEcsT0FBT0gsSUFBSSxHQUFHUztRQUNkTixPQUFPRixLQUFLLEdBQUdTO0lBQ2pCO0lBQ0EsSUFBSVQsT0FBTztRQUNURSxPQUFPRixLQUFLLEdBQUdBO0lBQ2pCO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLFNBQVNNLFlBQVlFLEdBQUc7SUFDdEIsT0FBT0EsSUFBSSxJQUFJO0FBQ2pCO0FBQ0EsU0FBU0QsYUFBYUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDakMsT0FBT0QsSUFDTCxJQUFJLEVBQ0osT0FBT0MsUUFBUSxhQUFhQSxJQUFJRixJQUFJLElBQUksS0FBS0U7QUFFakQ7QUFFQSxJQUFJQztBQUNKLFNBQVNDLDZCQUE2QkMsRUFBRTtJQUN0Q0YsdUJBQXVCRSxHQUFHRjtBQUM1QjtBQUNBLFNBQVNHO0lBQ1AsSUFBSUgsc0JBQXNCO1FBQ3hCLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPakIsZ0ZBQXVCQTtBQUNoQztBQUNBLElBQUlxQjtBQUNKLFNBQVNDO0lBQ1AsSUFBSSxDQUFDRCxjQUFjO1FBQ2pCQSxlQUFlRDtRQUNmLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztZQUN0RUcsV0FBV0MsdUJBQXVCLElBQUtELENBQUFBLFdBQVdDLHVCQUF1QixHQUFHSCxZQUFXO1lBQ3ZGLElBQUlFLFdBQVdDLHVCQUF1QixLQUFLSCxjQUFjO2dCQUN2REksUUFBUUMsSUFBSSxDQUNWO1lBRUo7UUFDRjtJQUNGO0lBQ0EsT0FBT0w7QUFDVDtBQUU0RSIsInNvdXJjZXMiOlsid2VicGFjazovL3RodW1ibmFpbC1kZXNpZ24vLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzPzliNzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSU5URVJOQUxfYnVpbGRTdG9yZVJldjIgfSBmcm9tICdqb3RhaS92YW5pbGxhL2ludGVybmFscyc7XG5cbmxldCBrZXlDb3VudCA9IDA7XG5mdW5jdGlvbiBhdG9tKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IGtleSA9IGBhdG9tJHsrK2tleUNvdW50fWA7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmRlYnVnTGFiZWwgPyBrZXkgKyBcIjpcIiArIHRoaXMuZGVidWdMYWJlbCA6IGtleTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZmlnLnJlYWQgPSByZWFkO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5pbml0ID0gcmVhZDtcbiAgICBjb25maWcucmVhZCA9IGRlZmF1bHRSZWFkO1xuICAgIGNvbmZpZy53cml0ZSA9IGRlZmF1bHRXcml0ZTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlYWQoZ2V0KSB7XG4gIHJldHVybiBnZXQodGhpcyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0V3JpdGUoZ2V0LCBzZXQsIGFyZykge1xuICByZXR1cm4gc2V0KFxuICAgIHRoaXMsXG4gICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgKTtcbn1cblxubGV0IG92ZXJpZGRlbkNyZWF0ZVN0b3JlO1xuZnVuY3Rpb24gSU5URVJOQUxfb3ZlcnJpZGVDcmVhdGVTdG9yZShmbikge1xuICBvdmVyaWRkZW5DcmVhdGVTdG9yZSA9IGZuKG92ZXJpZGRlbkNyZWF0ZVN0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKCkge1xuICBpZiAob3ZlcmlkZGVuQ3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gb3ZlcmlkZGVuQ3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gSU5URVJOQUxfYnVpbGRTdG9yZVJldjIoKTtcbn1cbmxldCBkZWZhdWx0U3RvcmU7XG5mdW5jdGlvbiBnZXREZWZhdWx0U3RvcmUoKSB7XG4gIGlmICghZGVmYXVsdFN0b3JlKSB7XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gfHwgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gPSBkZWZhdWx0U3RvcmUpO1xuICAgICAgaWYgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gIT09IGRlZmF1bHRTdG9yZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSBKb3RhaSBpbnN0YW5jZXMuIEl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIHdpdGggdGhlIGRlZmF1bHQgc3RvcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvZGlzY3Vzc2lvbnMvMjA0NFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0U3RvcmU7XG59XG5cbmV4cG9ydCB7IElOVEVSTkFMX292ZXJyaWRlQ3JlYXRlU3RvcmUsIGF0b20sIGNyZWF0ZVN0b3JlLCBnZXREZWZhdWx0U3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJJTlRFUk5BTF9idWlsZFN0b3JlUmV2MiIsImtleUNvdW50IiwiYXRvbSIsInJlYWQiLCJ3cml0ZSIsImtleSIsImNvbmZpZyIsInRvU3RyaW5nIiwiZW52IiwiTU9ERSIsImRlYnVnTGFiZWwiLCJpbml0IiwiZGVmYXVsdFJlYWQiLCJkZWZhdWx0V3JpdGUiLCJnZXQiLCJzZXQiLCJhcmciLCJvdmVyaWRkZW5DcmVhdGVTdG9yZSIsIklOVEVSTkFMX292ZXJyaWRlQ3JlYXRlU3RvcmUiLCJmbiIsImNyZWF0ZVN0b3JlIiwiZGVmYXVsdFN0b3JlIiwiZ2V0RGVmYXVsdFN0b3JlIiwiZ2xvYmFsVGhpcyIsIl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs":
/*!******************************************************!*\
  !*** ./node_modules/jotai/esm/vanilla/internals.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_abortPromise: () => (/* binding */ abortPromise),\n/* harmony export */   INTERNAL_addPendingPromiseToDependency: () => (/* binding */ addPendingPromiseToDependency),\n/* harmony export */   INTERNAL_buildStoreRev2: () => (/* binding */ buildStore),\n/* harmony export */   INTERNAL_getBuildingBlocksRev2: () => (/* binding */ getBuildingBlocks),\n/* harmony export */   INTERNAL_getMountedOrPendingDependents: () => (/* binding */ getMountedOrPendingDependents),\n/* harmony export */   INTERNAL_hasInitialValue: () => (/* binding */ hasInitialValue),\n/* harmony export */   INTERNAL_initializeStoreHooksRev2: () => (/* binding */ initializeStoreHooks),\n/* harmony export */   INTERNAL_isActuallyWritableAtom: () => (/* binding */ isActuallyWritableAtom),\n/* harmony export */   INTERNAL_isAtomStateInitialized: () => (/* binding */ isAtomStateInitialized),\n/* harmony export */   INTERNAL_isPendingPromise: () => (/* binding */ isPendingPromise),\n/* harmony export */   INTERNAL_isPromiseLike: () => (/* binding */ isPromiseLike),\n/* harmony export */   INTERNAL_promiseStateMap: () => (/* binding */ promiseStateMap),\n/* harmony export */   INTERNAL_registerAbortHandler: () => (/* binding */ registerAbortHandler),\n/* harmony export */   INTERNAL_returnAtomValue: () => (/* binding */ returnAtomValue)\n/* harmony export */ });\nfunction hasInitialValue(atom) {\n    return \"init\" in atom;\n}\nfunction isActuallyWritableAtom(atom) {\n    return !!atom.write;\n}\nfunction isAtomStateInitialized(atomState) {\n    return \"v\" in atomState || \"e\" in atomState;\n}\nfunction returnAtomValue(atomState) {\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    if (( false ? 0 : void 0) !== \"production\" && !(\"v\" in atomState)) {\n        throw new Error(\"[Bug] atom state is not initialized\");\n    }\n    return atomState.v;\n}\nconst promiseStateMap = /* @__PURE__ */ new WeakMap();\nfunction isPendingPromise(value) {\n    var _a;\n    return isPromiseLike(value) && !!((_a = promiseStateMap.get(value)) == null ? void 0 : _a[0]);\n}\nfunction abortPromise(promise) {\n    const promiseState = promiseStateMap.get(promise);\n    if (promiseState == null ? void 0 : promiseState[0]) {\n        promiseState[0] = false;\n        promiseState[1].forEach((fn)=>fn());\n    }\n}\nfunction registerAbortHandler(promise, abortHandler) {\n    let promiseState = promiseStateMap.get(promise);\n    if (!promiseState) {\n        promiseState = [\n            true,\n            /* @__PURE__ */ new Set()\n        ];\n        promiseStateMap.set(promise, promiseState);\n        const settle = ()=>{\n            promiseState[0] = false;\n        };\n        promise.then(settle, settle);\n    }\n    promiseState[1].add(abortHandler);\n}\nfunction isPromiseLike(p) {\n    return typeof (p == null ? void 0 : p.then) === \"function\";\n}\nfunction addPendingPromiseToDependency(atom, promise, dependencyAtomState) {\n    if (!dependencyAtomState.p.has(atom)) {\n        dependencyAtomState.p.add(atom);\n        const cleanup = ()=>dependencyAtomState.p.delete(atom);\n        promise.then(cleanup, cleanup);\n    }\n}\nfunction getMountedOrPendingDependents(atom, atomState, mountedMap) {\n    var _a;\n    const dependents = /* @__PURE__ */ new Set();\n    for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []){\n        dependents.add(a);\n    }\n    for (const atomWithPendingPromise of atomState.p){\n        dependents.add(atomWithPendingPromise);\n    }\n    return dependents;\n}\nconst createStoreHook = ()=>{\n    const callbacks = /* @__PURE__ */ new Set();\n    const notify = ()=>callbacks.forEach((fn)=>fn());\n    notify.add = (fn)=>{\n        callbacks.add(fn);\n        return ()=>callbacks.delete(fn);\n    };\n    return notify;\n};\nconst createStoreHookForAtoms = ()=>{\n    const all = {};\n    const callbacks = /* @__PURE__ */ new WeakMap();\n    const notify = (atom)=>{\n        var _a, _b;\n        (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn)=>fn(atom));\n        (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn)=>fn());\n    };\n    notify.add = (atom, fn)=>{\n        const key = atom || all;\n        let fns = callbacks.get(key);\n        if (!fns) {\n            fns = /* @__PURE__ */ new Set();\n            callbacks.set(key, fns);\n        }\n        fns.add(fn);\n        return ()=>{\n            fns.delete(fn);\n            if (!fns.size) {\n                callbacks.delete(key);\n            }\n        };\n    };\n    return notify;\n};\nfunction initializeStoreHooks(storeHooks) {\n    storeHooks.i || (storeHooks.i = createStoreHookForAtoms());\n    storeHooks.r || (storeHooks.r = createStoreHookForAtoms());\n    storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n    storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n    storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n    storeHooks.f || (storeHooks.f = createStoreHook());\n    return storeHooks;\n}\nconst BUILDING_BLOCK_atomRead = (_store, atom, ...params)=>atom.read(...params);\nconst BUILDING_BLOCK_atomWrite = (_store, atom, ...params)=>atom.write(...params);\nconst BUILDING_BLOCK_atomOnInit = (store, atom)=>{\n    if (atom.INTERNAL_onInit) {\n        return atom.INTERNAL_onInit(store);\n    }\n    if (atom.unstable_onInit) {\n        console.warn(\"[DEPRECATED] atom.unstable_onInit is renamed to atom.INTERNAL_onInit.\");\n        return atom.unstable_onInit(store);\n    }\n};\nconst BUILDING_BLOCK_atomOnMount = (_store, atom, setAtom)=>{\n    var _a;\n    return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n};\nconst BUILDING_BLOCK_ensureAtomState = (store, atom)=>{\n    var _a;\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const atomStateMap = buildingBlocks[0];\n    const storeHooks = buildingBlocks[6];\n    const atomOnInit = buildingBlocks[9];\n    if (( false ? 0 : void 0) !== \"production\" && !atom) {\n        throw new Error(\"Atom is undefined or null\");\n    }\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n        atomState = {\n            d: /* @__PURE__ */ new Map(),\n            p: /* @__PURE__ */ new Set(),\n            n: 0\n        };\n        atomStateMap.set(atom, atomState);\n        (_a = storeHooks.i) == null ? void 0 : _a.call(storeHooks, atom);\n        atomOnInit == null ? void 0 : atomOnInit(store, atom);\n    }\n    return atomState;\n};\nconst BUILDING_BLOCK_flushCallbacks = (store)=>{\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const changedAtoms = buildingBlocks[3];\n    const mountCallbacks = buildingBlocks[4];\n    const unmountCallbacks = buildingBlocks[5];\n    const storeHooks = buildingBlocks[6];\n    const recomputeInvalidatedAtoms = buildingBlocks[13];\n    const errors = [];\n    const call = (fn)=>{\n        try {\n            fn();\n        } catch (e) {\n            errors.push(e);\n        }\n    };\n    do {\n        if (storeHooks.f) {\n            call(storeHooks.f);\n        }\n        const callbacks = /* @__PURE__ */ new Set();\n        const add = callbacks.add.bind(callbacks);\n        changedAtoms.forEach((atom)=>{\n            var _a;\n            return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n        });\n        changedAtoms.clear();\n        unmountCallbacks.forEach(add);\n        unmountCallbacks.clear();\n        mountCallbacks.forEach(add);\n        mountCallbacks.clear();\n        callbacks.forEach(call);\n        if (changedAtoms.size) {\n            recomputeInvalidatedAtoms(store);\n        }\n    }while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n    if (errors.length) {\n        throw new AggregateError(errors);\n    }\n};\nconst BUILDING_BLOCK_recomputeInvalidatedAtoms = (store)=>{\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const invalidatedAtoms = buildingBlocks[2];\n    const changedAtoms = buildingBlocks[3];\n    const ensureAtomState = buildingBlocks[11];\n    const readAtomState = buildingBlocks[14];\n    const mountDependencies = buildingBlocks[17];\n    const topSortedReversed = [];\n    const visiting = /* @__PURE__ */ new WeakSet();\n    const visited = /* @__PURE__ */ new WeakSet();\n    const stack = Array.from(changedAtoms);\n    while(stack.length){\n        const a = stack[stack.length - 1];\n        const aState = ensureAtomState(store, a);\n        if (visited.has(a)) {\n            stack.pop();\n            continue;\n        }\n        if (visiting.has(a)) {\n            if (invalidatedAtoms.get(a) === aState.n) {\n                topSortedReversed.push([\n                    a,\n                    aState\n                ]);\n            } else if (( false ? 0 : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n                throw new Error(\"[Bug] invalidated atom exists\");\n            }\n            visited.add(a);\n            stack.pop();\n            continue;\n        }\n        visiting.add(a);\n        for (const d of getMountedOrPendingDependents(a, aState, mountedMap)){\n            if (!visiting.has(d)) {\n                stack.push(d);\n            }\n        }\n    }\n    for(let i = topSortedReversed.length - 1; i >= 0; --i){\n        const [a, aState] = topSortedReversed[i];\n        let hasChangedDeps = false;\n        for (const dep of aState.d.keys()){\n            if (dep !== a && changedAtoms.has(dep)) {\n                hasChangedDeps = true;\n                break;\n            }\n        }\n        if (hasChangedDeps) {\n            readAtomState(store, a);\n            mountDependencies(store, a);\n        }\n        invalidatedAtoms.delete(a);\n    }\n};\nconst storeMutationSet = /* @__PURE__ */ new WeakSet();\nconst BUILDING_BLOCK_readAtomState = (store, atom)=>{\n    var _a, _b;\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const invalidatedAtoms = buildingBlocks[2];\n    const changedAtoms = buildingBlocks[3];\n    const storeHooks = buildingBlocks[6];\n    const atomRead = buildingBlocks[7];\n    const ensureAtomState = buildingBlocks[11];\n    const flushCallbacks = buildingBlocks[12];\n    const recomputeInvalidatedAtoms = buildingBlocks[13];\n    const readAtomState = buildingBlocks[14];\n    const writeAtomState = buildingBlocks[16];\n    const mountDependencies = buildingBlocks[17];\n    const setAtomStateValueOrPromise = buildingBlocks[20];\n    const atomState = ensureAtomState(store, atom);\n    if (isAtomStateInitialized(atomState)) {\n        if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n            return atomState;\n        }\n        let hasChangedDeps = false;\n        for (const [a, n] of atomState.d){\n            if (readAtomState(store, a).n !== n) {\n                hasChangedDeps = true;\n                break;\n            }\n        }\n        if (!hasChangedDeps) {\n            return atomState;\n        }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    function mountDependenciesIfAsync() {\n        if (mountedMap.has(atom)) {\n            mountDependencies(store, atom);\n            recomputeInvalidatedAtoms(store);\n            flushCallbacks(store);\n        }\n    }\n    function getter(a) {\n        var _a2;\n        if (a === atom) {\n            const aState2 = ensureAtomState(store, a);\n            if (!isAtomStateInitialized(aState2)) {\n                if (hasInitialValue(a)) {\n                    setAtomStateValueOrPromise(store, a, a.init);\n                } else {\n                    throw new Error(\"no atom init\");\n                }\n            }\n            return returnAtomValue(aState2);\n        }\n        const aState = readAtomState(store, a);\n        try {\n            return returnAtomValue(aState);\n        } finally{\n            atomState.d.set(a, aState.n);\n            if (isPendingPromise(atomState.v)) {\n                addPendingPromiseToDependency(atom, atomState.v, aState);\n            }\n            if (mountedMap.has(atom)) {\n                (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n            }\n            if (!isSync) {\n                mountDependenciesIfAsync();\n            }\n        }\n    }\n    let controller;\n    let setSelf;\n    const options = {\n        get signal () {\n            if (!controller) {\n                controller = new AbortController();\n            }\n            return controller.signal;\n        },\n        get setSelf () {\n            if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                console.warn(\"setSelf function cannot be used with read-only atom\");\n            }\n            if (!setSelf && isActuallyWritableAtom(atom)) {\n                setSelf = (...args)=>{\n                    if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                        console.warn(\"setSelf function cannot be called in sync\");\n                    }\n                    if (!isSync) {\n                        try {\n                            return writeAtomState(store, atom, ...args);\n                        } finally{\n                            recomputeInvalidatedAtoms(store);\n                            flushCallbacks(store);\n                        }\n                    }\n                };\n            }\n            return setSelf;\n        }\n    };\n    const prevEpochNumber = atomState.n;\n    try {\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeMutationSet.delete(store);\n        }\n        const valueOrPromise = atomRead(store, atom, getter, options);\n        if (( false ? 0 : void 0) !== \"production\" && storeMutationSet.has(store)) {\n            console.warn(\"Detected store mutation during atom read. This is not supported.\");\n        }\n        setAtomStateValueOrPromise(store, atom, valueOrPromise);\n        if (isPromiseLike(valueOrPromise)) {\n            registerAbortHandler(valueOrPromise, ()=>controller == null ? void 0 : controller.abort());\n            valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n        }\n        (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom);\n        return atomState;\n    } catch (error) {\n        delete atomState.v;\n        atomState.e = error;\n        ++atomState.n;\n        return atomState;\n    } finally{\n        isSync = false;\n        if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n            invalidatedAtoms.set(atom, atomState.n);\n            changedAtoms.add(atom);\n            (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom);\n        }\n    }\n};\nconst BUILDING_BLOCK_invalidateDependents = (store, atom)=>{\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const invalidatedAtoms = buildingBlocks[2];\n    const ensureAtomState = buildingBlocks[11];\n    const stack = [\n        atom\n    ];\n    while(stack.length){\n        const a = stack.pop();\n        const aState = ensureAtomState(store, a);\n        for (const d of getMountedOrPendingDependents(a, aState, mountedMap)){\n            const dState = ensureAtomState(store, d);\n            invalidatedAtoms.set(d, dState.n);\n            stack.push(d);\n        }\n    }\n};\nconst BUILDING_BLOCK_writeAtomState = (store, atom, ...args)=>{\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const changedAtoms = buildingBlocks[3];\n    const storeHooks = buildingBlocks[6];\n    const atomWrite = buildingBlocks[8];\n    const ensureAtomState = buildingBlocks[11];\n    const flushCallbacks = buildingBlocks[12];\n    const recomputeInvalidatedAtoms = buildingBlocks[13];\n    const readAtomState = buildingBlocks[14];\n    const invalidateDependents = buildingBlocks[15];\n    const writeAtomState = buildingBlocks[16];\n    const mountDependencies = buildingBlocks[17];\n    const setAtomStateValueOrPromise = buildingBlocks[20];\n    let isSync = true;\n    const getter = (a)=>returnAtomValue(readAtomState(store, a));\n    const setter = (a, ...args2)=>{\n        var _a;\n        const aState = ensureAtomState(store, a);\n        try {\n            if (a === atom) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                if (( false ? 0 : void 0) !== \"production\") {\n                    storeMutationSet.add(store);\n                }\n                const prevEpochNumber = aState.n;\n                const v = args2[0];\n                setAtomStateValueOrPromise(store, a, v);\n                mountDependencies(store, a);\n                if (prevEpochNumber !== aState.n) {\n                    changedAtoms.add(a);\n                    invalidateDependents(store, a);\n                    (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n                }\n                return void 0;\n            } else {\n                return writeAtomState(store, a, ...args2);\n            }\n        } finally{\n            if (!isSync) {\n                recomputeInvalidatedAtoms(store);\n                flushCallbacks(store);\n            }\n        }\n    };\n    try {\n        return atomWrite(store, atom, getter, setter, ...args);\n    } finally{\n        isSync = false;\n    }\n};\nconst BUILDING_BLOCK_mountDependencies = (store, atom)=>{\n    var _a;\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const changedAtoms = buildingBlocks[3];\n    const storeHooks = buildingBlocks[6];\n    const ensureAtomState = buildingBlocks[11];\n    const invalidateDependents = buildingBlocks[15];\n    const mountAtom = buildingBlocks[18];\n    const unmountAtom = buildingBlocks[19];\n    const atomState = ensureAtomState(store, atom);\n    const mounted = mountedMap.get(atom);\n    if (mounted && !isPendingPromise(atomState.v)) {\n        for (const [a, n] of atomState.d){\n            if (!mounted.d.has(a)) {\n                const aState = ensureAtomState(store, a);\n                const aMounted = mountAtom(store, a);\n                aMounted.t.add(atom);\n                mounted.d.add(a);\n                if (n !== aState.n) {\n                    changedAtoms.add(a);\n                    invalidateDependents(store, a);\n                    (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n                }\n            }\n        }\n        for (const a of mounted.d){\n            if (!atomState.d.has(a)) {\n                mounted.d.delete(a);\n                const aMounted = unmountAtom(store, a);\n                aMounted == null ? void 0 : aMounted.t.delete(atom);\n            }\n        }\n    }\n};\nconst BUILDING_BLOCK_mountAtom = (store, atom)=>{\n    var _a;\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const mountCallbacks = buildingBlocks[4];\n    const storeHooks = buildingBlocks[6];\n    const atomOnMount = buildingBlocks[10];\n    const ensureAtomState = buildingBlocks[11];\n    const flushCallbacks = buildingBlocks[12];\n    const recomputeInvalidatedAtoms = buildingBlocks[13];\n    const readAtomState = buildingBlocks[14];\n    const writeAtomState = buildingBlocks[16];\n    const mountAtom = buildingBlocks[18];\n    const atomState = ensureAtomState(store, atom);\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n        readAtomState(store, atom);\n        for (const a of atomState.d.keys()){\n            const aMounted = mountAtom(store, a);\n            aMounted.t.add(atom);\n        }\n        mounted = {\n            l: /* @__PURE__ */ new Set(),\n            d: new Set(atomState.d.keys()),\n            t: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (isActuallyWritableAtom(atom)) {\n            const processOnMount = ()=>{\n                let isSync = true;\n                const setAtom = (...args)=>{\n                    try {\n                        return writeAtomState(store, atom, ...args);\n                    } finally{\n                        if (!isSync) {\n                            recomputeInvalidatedAtoms(store);\n                            flushCallbacks(store);\n                        }\n                    }\n                };\n                try {\n                    const onUnmount = atomOnMount(store, atom, setAtom);\n                    if (onUnmount) {\n                        mounted.u = ()=>{\n                            isSync = true;\n                            try {\n                                onUnmount();\n                            } finally{\n                                isSync = false;\n                            }\n                        };\n                    }\n                } finally{\n                    isSync = false;\n                }\n            };\n            mountCallbacks.add(processOnMount);\n        }\n        (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n    }\n    return mounted;\n};\nconst BUILDING_BLOCK_unmountAtom = (store, atom)=>{\n    var _a, _b;\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const mountedMap = buildingBlocks[1];\n    const unmountCallbacks = buildingBlocks[5];\n    const storeHooks = buildingBlocks[6];\n    const ensureAtomState = buildingBlocks[11];\n    const unmountAtom = buildingBlocks[19];\n    const atomState = ensureAtomState(store, atom);\n    let mounted = mountedMap.get(atom);\n    if (!mounted || mounted.l.size) {\n        return mounted;\n    }\n    let isDependent = false;\n    for (const a of mounted.t){\n        if ((_a = mountedMap.get(a)) == null ? void 0 : _a.d.has(atom)) {\n            isDependent = true;\n            break;\n        }\n    }\n    if (!isDependent) {\n        if (mounted.u) {\n            unmountCallbacks.add(mounted.u);\n        }\n        mounted = void 0;\n        mountedMap.delete(atom);\n        for (const a of atomState.d.keys()){\n            const aMounted = unmountAtom(store, a);\n            aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n        (_b = storeHooks.u) == null ? void 0 : _b.call(storeHooks, atom);\n        return void 0;\n    }\n    return mounted;\n};\nconst BUILDING_BLOCK_setAtomStateValueOrPromise = (store, atom, valueOrPromise)=>{\n    const ensureAtomState = getInternalBuildingBlocks(store)[11];\n    const atomState = ensureAtomState(store, atom);\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    if (isPromiseLike(valueOrPromise)) {\n        for (const a of atomState.d.keys()){\n            addPendingPromiseToDependency(atom, valueOrPromise, ensureAtomState(store, a));\n        }\n    }\n    atomState.v = valueOrPromise;\n    delete atomState.e;\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n        ++atomState.n;\n        if (isPromiseLike(prevValue)) {\n            abortPromise(prevValue);\n        }\n    }\n};\nconst BUILDING_BLOCK_storeGet = (store, atom)=>{\n    const readAtomState = getInternalBuildingBlocks(store)[14];\n    return returnAtomValue(readAtomState(store, atom));\n};\nconst BUILDING_BLOCK_storeSet = (store, atom, ...args)=>{\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const flushCallbacks = buildingBlocks[12];\n    const recomputeInvalidatedAtoms = buildingBlocks[13];\n    const writeAtomState = buildingBlocks[16];\n    try {\n        return writeAtomState(store, atom, ...args);\n    } finally{\n        recomputeInvalidatedAtoms(store);\n        flushCallbacks(store);\n    }\n};\nconst BUILDING_BLOCK_storeSub = (store, atom, listener)=>{\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const flushCallbacks = buildingBlocks[12];\n    const mountAtom = buildingBlocks[18];\n    const unmountAtom = buildingBlocks[19];\n    const mounted = mountAtom(store, atom);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    flushCallbacks(store);\n    return ()=>{\n        listeners.delete(listener);\n        unmountAtom(store, atom);\n        flushCallbacks(store);\n    };\n};\nconst buildingBlockMap = /* @__PURE__ */ new WeakMap();\nconst getInternalBuildingBlocks = (store)=>{\n    const buildingBlocks = buildingBlockMap.get(store);\n    if (( false ? 0 : void 0) !== \"production\" && !buildingBlocks) {\n        throw new Error(\"Store must be created by buildStore to read its building blocks\");\n    }\n    return buildingBlocks;\n};\nfunction getBuildingBlocks(store) {\n    const buildingBlocks = getInternalBuildingBlocks(store);\n    const enhanceBuildingBlocks = buildingBlocks[24];\n    if (enhanceBuildingBlocks) {\n        return enhanceBuildingBlocks(buildingBlocks);\n    }\n    return buildingBlocks;\n}\nfunction buildStore(...buildArgs) {\n    const store = {\n        get (atom) {\n            const storeGet = getInternalBuildingBlocks(store)[21];\n            return storeGet(store, atom);\n        },\n        set (atom, ...args) {\n            const storeSet = getInternalBuildingBlocks(store)[22];\n            return storeSet(store, atom, ...args);\n        },\n        sub (atom, listener) {\n            const storeSub = getInternalBuildingBlocks(store)[23];\n            return storeSub(store, atom, listener);\n        }\n    };\n    const buildingBlocks = [\n        // store state\n        /* @__PURE__ */ new WeakMap(),\n        // atomStateMap\n        /* @__PURE__ */ new WeakMap(),\n        // mountedMap\n        /* @__PURE__ */ new WeakMap(),\n        // invalidatedAtoms\n        /* @__PURE__ */ new Set(),\n        // changedAtoms\n        /* @__PURE__ */ new Set(),\n        // mountCallbacks\n        /* @__PURE__ */ new Set(),\n        // unmountCallbacks\n        {},\n        // storeHooks\n        // atom interceptors\n        BUILDING_BLOCK_atomRead,\n        BUILDING_BLOCK_atomWrite,\n        BUILDING_BLOCK_atomOnInit,\n        BUILDING_BLOCK_atomOnMount,\n        // building-block functions\n        BUILDING_BLOCK_ensureAtomState,\n        BUILDING_BLOCK_flushCallbacks,\n        BUILDING_BLOCK_recomputeInvalidatedAtoms,\n        BUILDING_BLOCK_readAtomState,\n        BUILDING_BLOCK_invalidateDependents,\n        BUILDING_BLOCK_writeAtomState,\n        BUILDING_BLOCK_mountDependencies,\n        BUILDING_BLOCK_mountAtom,\n        BUILDING_BLOCK_unmountAtom,\n        BUILDING_BLOCK_setAtomStateValueOrPromise,\n        BUILDING_BLOCK_storeGet,\n        BUILDING_BLOCK_storeSet,\n        BUILDING_BLOCK_storeSub,\n        void 0\n    ].map((fn, i)=>buildArgs[i] || fn);\n    buildingBlockMap.set(store, Object.freeze(buildingBlocks));\n    return store;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvaW50ZXJuYWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGdCQUFnQkMsSUFBSTtJQUMzQixPQUFPLFVBQVVBO0FBQ25CO0FBQ0EsU0FBU0MsdUJBQXVCRCxJQUFJO0lBQ2xDLE9BQU8sQ0FBQyxDQUFDQSxLQUFLRSxLQUFLO0FBQ3JCO0FBQ0EsU0FBU0MsdUJBQXVCQyxTQUFTO0lBQ3ZDLE9BQU8sT0FBT0EsYUFBYSxPQUFPQTtBQUNwQztBQUNBLFNBQVNDLGdCQUFnQkQsU0FBUztJQUNoQyxJQUFJLE9BQU9BLFdBQVc7UUFDcEIsTUFBTUEsVUFBVUUsQ0FBQztJQUNuQjtJQUNBLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsUUFBT0YsU0FBUSxHQUFJO1FBQzdGLE1BQU0sSUFBSUssTUFBTTtJQUNsQjtJQUNBLE9BQU9MLFVBQVVNLENBQUM7QUFDcEI7QUFDQSxNQUFNQyxrQkFBa0IsYUFBYSxHQUFHLElBQUlDO0FBQzVDLFNBQVNDLGlCQUFpQkMsS0FBSztJQUM3QixJQUFJQztJQUNKLE9BQU9DLGNBQWNGLFVBQVUsQ0FBQyxDQUFFLEVBQUNDLEtBQUtKLGdCQUFnQk0sR0FBRyxDQUFDSCxNQUFLLEtBQU0sT0FBTyxLQUFLLElBQUlDLEVBQUUsQ0FBQyxFQUFFO0FBQzlGO0FBQ0EsU0FBU0csYUFBYUMsT0FBTztJQUMzQixNQUFNQyxlQUFlVCxnQkFBZ0JNLEdBQUcsQ0FBQ0U7SUFDekMsSUFBSUMsZ0JBQWdCLE9BQU8sS0FBSyxJQUFJQSxZQUFZLENBQUMsRUFBRSxFQUFFO1FBQ25EQSxZQUFZLENBQUMsRUFBRSxHQUFHO1FBQ2xCQSxZQUFZLENBQUMsRUFBRSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsS0FBT0E7SUFDbEM7QUFDRjtBQUNBLFNBQVNDLHFCQUFxQkosT0FBTyxFQUFFSyxZQUFZO0lBQ2pE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QUMvQjtJQUNGO0lBQ0EsTUFBTXBGLGlCQUFpQjtRQUNyQixjQUFjO1FBQ2QsYUFBYSxHQUFHLElBQUkvRDtRQUNwQixlQUFlO1FBQ2YsYUFBYSxHQUFHLElBQUlBO1FBQ3BCLGFBQWE7UUFDYixhQUFhLEdBQUcsSUFBSUE7UUFDcEIsbUJBQW1CO1FBQ25CLGFBQWEsR0FBRyxJQUFJYTtRQUNwQixlQUFlO1FBQ2YsYUFBYSxHQUFHLElBQUlBO1FBQ3BCLGlCQUFpQjtRQUNqQixhQUFhLEdBQUcsSUFBSUE7UUFDcEIsbUJBQW1CO1FBQ25CLENBQUM7UUFDRCxhQUFhO1FBQ2Isb0JBQW9CO1FBQ3BCa0M7UUFDQUk7UUFDQUM7UUFDQU07UUFDQSwyQkFBMkI7UUFDM0JJO1FBQ0FRO1FBQ0FZO1FBQ0FrQjtRQUNBcUI7UUFDQUU7UUFDQUs7UUFDQUs7UUFDQUk7UUFDQUU7UUFDQUs7UUFDQUM7UUFDQUM7UUFDQSxLQUFLO0tBQ04sQ0FBQ1ksR0FBRyxDQUFDLENBQUNwSixJQUFJK0IsSUFBTWdILFNBQVMsQ0FBQ2hILEVBQUUsSUFBSS9CO0lBQ2pDMkksaUJBQWlCdkksR0FBRyxDQUFDdUMsT0FBT3lGLE9BQU9pQixNQUFNLENBQUNoRztJQUMxQyxPQUFPVjtBQUNUO0FBRXN1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RodW1ibmFpbC1kZXNpZ24vLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEvaW50ZXJuYWxzLm1qcz9jYTFmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhhc0luaXRpYWxWYWx1ZShhdG9tKSB7XG4gIHJldHVybiBcImluaXRcIiBpbiBhdG9tO1xufVxuZnVuY3Rpb24gaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSB7XG4gIHJldHVybiAhIWF0b20ud3JpdGU7XG59XG5mdW5jdGlvbiBpc0F0b21TdGF0ZUluaXRpYWxpemVkKGF0b21TdGF0ZSkge1xuICByZXR1cm4gXCJ2XCIgaW4gYXRvbVN0YXRlIHx8IFwiZVwiIGluIGF0b21TdGF0ZTtcbn1cbmZ1bmN0aW9uIHJldHVybkF0b21WYWx1ZShhdG9tU3RhdGUpIHtcbiAgaWYgKFwiZVwiIGluIGF0b21TdGF0ZSkge1xuICAgIHRocm93IGF0b21TdGF0ZS5lO1xuICB9XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwidlwiIGluIGF0b21TdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQnVnXSBhdG9tIHN0YXRlIGlzIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfVxuICByZXR1cm4gYXRvbVN0YXRlLnY7XG59XG5jb25zdCBwcm9taXNlU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGlzUGVuZGluZ1Byb21pc2UodmFsdWUpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgJiYgISEoKF9hID0gcHJvbWlzZVN0YXRlTWFwLmdldCh2YWx1ZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSk7XG59XG5mdW5jdGlvbiBhYm9ydFByb21pc2UocHJvbWlzZSkge1xuICBjb25zdCBwcm9taXNlU3RhdGUgPSBwcm9taXNlU3RhdGVNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAocHJvbWlzZVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcm9taXNlU3RhdGVbMF0pIHtcbiAgICBwcm9taXNlU3RhdGVbMF0gPSBmYWxzZTtcbiAgICBwcm9taXNlU3RhdGVbMV0uZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG59XG5mdW5jdGlvbiByZWdpc3RlckFib3J0SGFuZGxlcihwcm9taXNlLCBhYm9ydEhhbmRsZXIpIHtcbiAgbGV0IHByb21pc2VTdGF0ZSA9IHByb21pc2VTdGF0ZU1hcC5nZXQocHJvbWlzZSk7XG4gIGlmICghcHJvbWlzZVN0YXRlKSB7XG4gICAgcHJvbWlzZVN0YXRlID0gW3RydWUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldO1xuICAgIHByb21pc2VTdGF0ZU1hcC5zZXQocHJvbWlzZSwgcHJvbWlzZVN0YXRlKTtcbiAgICBjb25zdCBzZXR0bGUgPSAoKSA9PiB7XG4gICAgICBwcm9taXNlU3RhdGVbMF0gPSBmYWxzZTtcbiAgICB9O1xuICAgIHByb21pc2UudGhlbihzZXR0bGUsIHNldHRsZSk7XG4gIH1cbiAgcHJvbWlzZVN0YXRlWzFdLmFkZChhYm9ydEhhbmRsZXIpO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlTGlrZShwKSB7XG4gIHJldHVybiB0eXBlb2YgKHAgPT0gbnVsbCA/IHZvaWQgMCA6IHAudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGFkZFBlbmRpbmdQcm9taXNlVG9EZXBlbmRlbmN5KGF0b20sIHByb21pc2UsIGRlcGVuZGVuY3lBdG9tU3RhdGUpIHtcbiAgaWYgKCFkZXBlbmRlbmN5QXRvbVN0YXRlLnAuaGFzKGF0b20pKSB7XG4gICAgZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmFkZChhdG9tKTtcbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4gZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmRlbGV0ZShhdG9tKTtcbiAgICBwcm9taXNlLnRoZW4oY2xlYW51cCwgY2xlYW51cCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1vdW50ZWRPclBlbmRpbmdEZXBlbmRlbnRzKGF0b20sIGF0b21TdGF0ZSwgbW91bnRlZE1hcCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGRlcGVuZGVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGEgb2YgKChfYSA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudCkgfHwgW10pIHtcbiAgICBkZXBlbmRlbnRzLmFkZChhKTtcbiAgfVxuICBmb3IgKGNvbnN0IGF0b21XaXRoUGVuZGluZ1Byb21pc2Ugb2YgYXRvbVN0YXRlLnApIHtcbiAgICBkZXBlbmRlbnRzLmFkZChhdG9tV2l0aFBlbmRpbmdQcm9taXNlKTtcbiAgfVxuICByZXR1cm4gZGVwZW5kZW50cztcbn1cbmNvbnN0IGNyZWF0ZVN0b3JlSG9vayA9ICgpID0+IHtcbiAgY29uc3QgY2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgbm90aWZ5ID0gKCkgPT4gY2FsbGJhY2tzLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgbm90aWZ5LmFkZCA9IChmbikgPT4ge1xuICAgIGNhbGxiYWNrcy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBjYWxsYmFja3MuZGVsZXRlKGZuKTtcbiAgfTtcbiAgcmV0dXJuIG5vdGlmeTtcbn07XG5jb25zdCBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcyA9ICgpID0+IHtcbiAgY29uc3QgYWxsID0ge307XG4gIGNvbnN0IGNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBub3RpZnkgPSAoYXRvbSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gY2FsbGJhY2tzLmdldChhbGwpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoZm4pID0+IGZuKGF0b20pKTtcbiAgICAoX2IgPSBjYWxsYmFja3MuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9O1xuICBub3RpZnkuYWRkID0gKGF0b20sIGZuKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYXRvbSB8fCBhbGw7XG4gICAgbGV0IGZucyA9IGNhbGxiYWNrcy5nZXQoa2V5KTtcbiAgICBpZiAoIWZucykge1xuICAgICAgZm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGNhbGxiYWNrcy5zZXQoa2V5LCBmbnMpO1xuICAgIH1cbiAgICBmbnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm5zLmRlbGV0ZShmbik7XG4gICAgICBpZiAoIWZucy5zaXplKSB7XG4gICAgICAgIGNhbGxiYWNrcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gbm90aWZ5O1xufTtcbmZ1bmN0aW9uIGluaXRpYWxpemVTdG9yZUhvb2tzKHN0b3JlSG9va3MpIHtcbiAgc3RvcmVIb29rcy5pIHx8IChzdG9yZUhvb2tzLmkgPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy5yIHx8IChzdG9yZUhvb2tzLnIgPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy5jIHx8IChzdG9yZUhvb2tzLmMgPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy5tIHx8IChzdG9yZUhvb2tzLm0gPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy51IHx8IChzdG9yZUhvb2tzLnUgPSBjcmVhdGVTdG9yZUhvb2tGb3JBdG9tcygpKTtcbiAgc3RvcmVIb29rcy5mIHx8IChzdG9yZUhvb2tzLmYgPSBjcmVhdGVTdG9yZUhvb2soKSk7XG4gIHJldHVybiBzdG9yZUhvb2tzO1xufVxuY29uc3QgQlVJTERJTkdfQkxPQ0tfYXRvbVJlYWQgPSAoX3N0b3JlLCBhdG9tLCAuLi5wYXJhbXMpID0+IGF0b20ucmVhZCguLi5wYXJhbXMpO1xuY29uc3QgQlVJTERJTkdfQkxPQ0tfYXRvbVdyaXRlID0gKF9zdG9yZSwgYXRvbSwgLi4ucGFyYW1zKSA9PiBhdG9tLndyaXRlKC4uLnBhcmFtcyk7XG5jb25zdCBCVUlMRElOR19CTE9DS19hdG9tT25Jbml0ID0gKHN0b3JlLCBhdG9tKSA9PiB7XG4gIGlmIChhdG9tLklOVEVSTkFMX29uSW5pdCkge1xuICAgIHJldHVybiBhdG9tLklOVEVSTkFMX29uSW5pdChzdG9yZSk7XG4gIH1cbiAgaWYgKGF0b20udW5zdGFibGVfb25Jbml0KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbREVQUkVDQVRFRF0gYXRvbS51bnN0YWJsZV9vbkluaXQgaXMgcmVuYW1lZCB0byBhdG9tLklOVEVSTkFMX29uSW5pdC5cIlxuICAgICk7XG4gICAgcmV0dXJuIGF0b20udW5zdGFibGVfb25Jbml0KHN0b3JlKTtcbiAgfVxufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLX2F0b21Pbk1vdW50ID0gKF9zdG9yZSwgYXRvbSwgc2V0QXRvbSkgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBhdG9tLm9uTW91bnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGF0b20sIHNldEF0b20pO1xufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLX2Vuc3VyZUF0b21TdGF0ZSA9IChzdG9yZSwgYXRvbSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGJ1aWxkaW5nQmxvY2tzID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSk7XG4gIGNvbnN0IGF0b21TdGF0ZU1hcCA9IGJ1aWxkaW5nQmxvY2tzWzBdO1xuICBjb25zdCBzdG9yZUhvb2tzID0gYnVpbGRpbmdCbG9ja3NbNl07XG4gIGNvbnN0IGF0b21PbkluaXQgPSBidWlsZGluZ0Jsb2Nrc1s5XTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFhdG9tKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXRvbSBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKTtcbiAgfVxuICBsZXQgYXRvbVN0YXRlID0gYXRvbVN0YXRlTWFwLmdldChhdG9tKTtcbiAgaWYgKCFhdG9tU3RhdGUpIHtcbiAgICBhdG9tU3RhdGUgPSB7IGQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG46IDAgfTtcbiAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgKF9hID0gc3RvcmVIb29rcy5pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdG9yZUhvb2tzLCBhdG9tKTtcbiAgICBhdG9tT25Jbml0ID09IG51bGwgPyB2b2lkIDAgOiBhdG9tT25Jbml0KHN0b3JlLCBhdG9tKTtcbiAgfVxuICByZXR1cm4gYXRvbVN0YXRlO1xufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLX2ZsdXNoQ2FsbGJhY2tzID0gKHN0b3JlKSA9PiB7XG4gIGNvbnN0IGJ1aWxkaW5nQmxvY2tzID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSk7XG4gIGNvbnN0IG1vdW50ZWRNYXAgPSBidWlsZGluZ0Jsb2Nrc1sxXTtcbiAgY29uc3QgY2hhbmdlZEF0b21zID0gYnVpbGRpbmdCbG9ja3NbM107XG4gIGNvbnN0IG1vdW50Q2FsbGJhY2tzID0gYnVpbGRpbmdCbG9ja3NbNF07XG4gIGNvbnN0IHVubW91bnRDYWxsYmFja3MgPSBidWlsZGluZ0Jsb2Nrc1s1XTtcbiAgY29uc3Qgc3RvcmVIb29rcyA9IGJ1aWxkaW5nQmxvY2tzWzZdO1xuICBjb25zdCByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zID0gYnVpbGRpbmdCbG9ja3NbMTNdO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgY2FsbCA9IChmbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgIH1cbiAgfTtcbiAgZG8ge1xuICAgIGlmIChzdG9yZUhvb2tzLmYpIHtcbiAgICAgIGNhbGwoc3RvcmVIb29rcy5mKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBhZGQgPSBjYWxsYmFja3MuYWRkLmJpbmQoY2FsbGJhY2tzKTtcbiAgICBjaGFuZ2VkQXRvbXMuZm9yRWFjaCgoYXRvbSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EubC5mb3JFYWNoKGFkZCk7XG4gICAgfSk7XG4gICAgY2hhbmdlZEF0b21zLmNsZWFyKCk7XG4gICAgdW5tb3VudENhbGxiYWNrcy5mb3JFYWNoKGFkZCk7XG4gICAgdW5tb3VudENhbGxiYWNrcy5jbGVhcigpO1xuICAgIG1vdW50Q2FsbGJhY2tzLmZvckVhY2goYWRkKTtcbiAgICBtb3VudENhbGxiYWNrcy5jbGVhcigpO1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGwpO1xuICAgIGlmIChjaGFuZ2VkQXRvbXMuc2l6ZSkge1xuICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcyhzdG9yZSk7XG4gICAgfVxuICB9IHdoaWxlIChjaGFuZ2VkQXRvbXMuc2l6ZSB8fCB1bm1vdW50Q2FsbGJhY2tzLnNpemUgfHwgbW91bnRDYWxsYmFja3Muc2l6ZSk7XG4gIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycyk7XG4gIH1cbn07XG5jb25zdCBCVUlMRElOR19CTE9DS19yZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zID0gKHN0b3JlKSA9PiB7XG4gIGNvbnN0IGJ1aWxkaW5nQmxvY2tzID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSk7XG4gIGNvbnN0IG1vdW50ZWRNYXAgPSBidWlsZGluZ0Jsb2Nrc1sxXTtcbiAgY29uc3QgaW52YWxpZGF0ZWRBdG9tcyA9IGJ1aWxkaW5nQmxvY2tzWzJdO1xuICBjb25zdCBjaGFuZ2VkQXRvbXMgPSBidWlsZGluZ0Jsb2Nrc1szXTtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTFdO1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTRdO1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IGJ1aWxkaW5nQmxvY2tzWzE3XTtcbiAgY29uc3QgdG9wU29ydGVkUmV2ZXJzZWQgPSBbXTtcbiAgY29uc3QgdmlzaXRpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICBjb25zdCBzdGFjayA9IEFycmF5LmZyb20oY2hhbmdlZEF0b21zKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGEgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBhU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoc3RvcmUsIGEpO1xuICAgIGlmICh2aXNpdGVkLmhhcyhhKSkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZpc2l0aW5nLmhhcyhhKSkge1xuICAgICAgaWYgKGludmFsaWRhdGVkQXRvbXMuZ2V0KGEpID09PSBhU3RhdGUubikge1xuICAgICAgICB0b3BTb3J0ZWRSZXZlcnNlZC5wdXNoKFthLCBhU3RhdGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaW52YWxpZGF0ZWRBdG9tcy5oYXMoYSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0J1Z10gaW52YWxpZGF0ZWQgYXRvbSBleGlzdHNcIik7XG4gICAgICB9XG4gICAgICB2aXNpdGVkLmFkZChhKTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZpc2l0aW5nLmFkZChhKTtcbiAgICBmb3IgKGNvbnN0IGQgb2YgZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMoYSwgYVN0YXRlLCBtb3VudGVkTWFwKSkge1xuICAgICAgaWYgKCF2aXNpdGluZy5oYXMoZCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IHRvcFNvcnRlZFJldmVyc2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgW2EsIGFTdGF0ZV0gPSB0b3BTb3J0ZWRSZXZlcnNlZFtpXTtcbiAgICBsZXQgaGFzQ2hhbmdlZERlcHMgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBhU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgIGlmIChkZXAgIT09IGEgJiYgY2hhbmdlZEF0b21zLmhhcyhkZXApKSB7XG4gICAgICAgIGhhc0NoYW5nZWREZXBzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgcmVhZEF0b21TdGF0ZShzdG9yZSwgYSk7XG4gICAgICBtb3VudERlcGVuZGVuY2llcyhzdG9yZSwgYSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVkQXRvbXMuZGVsZXRlKGEpO1xuICB9XG59O1xuY29uc3Qgc3RvcmVNdXRhdGlvblNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY29uc3QgQlVJTERJTkdfQkxPQ0tfcmVhZEF0b21TdGF0ZSA9IChzdG9yZSwgYXRvbSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpO1xuICBjb25zdCBtb3VudGVkTWFwID0gYnVpbGRpbmdCbG9ja3NbMV07XG4gIGNvbnN0IGludmFsaWRhdGVkQXRvbXMgPSBidWlsZGluZ0Jsb2Nrc1syXTtcbiAgY29uc3QgY2hhbmdlZEF0b21zID0gYnVpbGRpbmdCbG9ja3NbM107XG4gIGNvbnN0IHN0b3JlSG9va3MgPSBidWlsZGluZ0Jsb2Nrc1s2XTtcbiAgY29uc3QgYXRvbVJlYWQgPSBidWlsZGluZ0Jsb2Nrc1s3XTtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTFdO1xuICBjb25zdCBmbHVzaENhbGxiYWNrcyA9IGJ1aWxkaW5nQmxvY2tzWzEyXTtcbiAgY29uc3QgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcyA9IGJ1aWxkaW5nQmxvY2tzWzEzXTtcbiAgY29uc3QgcmVhZEF0b21TdGF0ZSA9IGJ1aWxkaW5nQmxvY2tzWzE0XTtcbiAgY29uc3Qgd3JpdGVBdG9tU3RhdGUgPSBidWlsZGluZ0Jsb2Nrc1sxNl07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gYnVpbGRpbmdCbG9ja3NbMTddO1xuICBjb25zdCBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IGJ1aWxkaW5nQmxvY2tzWzIwXTtcbiAgY29uc3QgYXRvbVN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKHN0b3JlLCBhdG9tKTtcbiAgaWYgKGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQoYXRvbVN0YXRlKSkge1xuICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSAmJiBpbnZhbGlkYXRlZEF0b21zLmdldChhdG9tKSAhPT0gYXRvbVN0YXRlLm4pIHtcbiAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgfVxuICAgIGxldCBoYXNDaGFuZ2VkRGVwcyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW2EsIG5dIG9mIGF0b21TdGF0ZS5kKSB7XG4gICAgICBpZiAocmVhZEF0b21TdGF0ZShzdG9yZSwgYSkubiAhPT0gbikge1xuICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhc0NoYW5nZWREZXBzKSB7XG4gICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgIH1cbiAgfVxuICBhdG9tU3RhdGUuZC5jbGVhcigpO1xuICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgZnVuY3Rpb24gbW91bnREZXBlbmRlbmNpZXNJZkFzeW5jKCkge1xuICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgbW91bnREZXBlbmRlbmNpZXMoc3RvcmUsIGF0b20pO1xuICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcyhzdG9yZSk7XG4gICAgICBmbHVzaENhbGxiYWNrcyhzdG9yZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldHRlcihhKSB7XG4gICAgdmFyIF9hMjtcbiAgICBpZiAoYSA9PT0gYXRvbSkge1xuICAgICAgY29uc3QgYVN0YXRlMiA9IGVuc3VyZUF0b21TdGF0ZShzdG9yZSwgYSk7XG4gICAgICBpZiAoIWlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQoYVN0YXRlMikpIHtcbiAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKHN0b3JlLCBhLCBhLmluaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGF0b20gaW5pdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUyKTtcbiAgICB9XG4gICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShzdG9yZSwgYSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXRvbVN0YXRlLmQuc2V0KGEsIGFTdGF0ZS5uKTtcbiAgICAgIGlmIChpc1BlbmRpbmdQcm9taXNlKGF0b21TdGF0ZS52KSkge1xuICAgICAgICBhZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeShhdG9tLCBhdG9tU3RhdGUudiwgYVN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICAoX2EyID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudC5hZGQoYXRvbSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICBtb3VudERlcGVuZGVuY2llc0lmQXN5bmMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGxldCBzZXRTZWxmO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGdldCBzaWduYWwoKSB7XG4gICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICB9LFxuICAgIGdldCBzZXRTZWxmKCkge1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgd2l0aCByZWFkLW9ubHkgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgIHNldFNlbGYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1N5bmMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpbiBzeW5jXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlQXRvbVN0YXRlKHN0b3JlLCBhdG9tLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMoc3RvcmUpO1xuICAgICAgICAgICAgICBmbHVzaENhbGxiYWNrcyhzdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFNlbGY7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcmV2RXBvY2hOdW1iZXIgPSBhdG9tU3RhdGUubjtcbiAgdHJ5IHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHN0b3JlTXV0YXRpb25TZXQuZGVsZXRlKHN0b3JlKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVPclByb21pc2UgPSBhdG9tUmVhZChzdG9yZSwgYXRvbSwgZ2V0dGVyLCBvcHRpb25zKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgc3RvcmVNdXRhdGlvblNldC5oYXMoc3RvcmUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRGV0ZWN0ZWQgc3RvcmUgbXV0YXRpb24gZHVyaW5nIGF0b20gcmVhZC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZShzdG9yZSwgYXRvbSwgdmFsdWVPclByb21pc2UpO1xuICAgIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgcmVnaXN0ZXJBYm9ydEhhbmRsZXIodmFsdWVPclByb21pc2UsICgpID0+IGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICB2YWx1ZU9yUHJvbWlzZS50aGVuKG1vdW50RGVwZW5kZW5jaWVzSWZBc3luYywgbW91bnREZXBlbmRlbmNpZXNJZkFzeW5jKTtcbiAgICB9XG4gICAgKF9hID0gc3RvcmVIb29rcy5yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdG9yZUhvb2tzLCBhdG9tKTtcbiAgICByZXR1cm4gYXRvbVN0YXRlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRlbGV0ZSBhdG9tU3RhdGUudjtcbiAgICBhdG9tU3RhdGUuZSA9IGVycm9yO1xuICAgICsrYXRvbVN0YXRlLm47XG4gICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICBpZiAocHJldkVwb2NoTnVtYmVyICE9PSBhdG9tU3RhdGUubiAmJiBpbnZhbGlkYXRlZEF0b21zLmdldChhdG9tKSA9PT0gcHJldkVwb2NoTnVtYmVyKSB7XG4gICAgICBpbnZhbGlkYXRlZEF0b21zLnNldChhdG9tLCBhdG9tU3RhdGUubik7XG4gICAgICBjaGFuZ2VkQXRvbXMuYWRkKGF0b20pO1xuICAgICAgKF9iID0gc3RvcmVIb29rcy5jKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChzdG9yZUhvb2tzLCBhdG9tKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBCVUlMRElOR19CTE9DS19pbnZhbGlkYXRlRGVwZW5kZW50cyA9IChzdG9yZSwgYXRvbSkgPT4ge1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpO1xuICBjb25zdCBtb3VudGVkTWFwID0gYnVpbGRpbmdCbG9ja3NbMV07XG4gIGNvbnN0IGludmFsaWRhdGVkQXRvbXMgPSBidWlsZGluZ0Jsb2Nrc1syXTtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTFdO1xuICBjb25zdCBzdGFjayA9IFthdG9tXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGEgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBhU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoc3RvcmUsIGEpO1xuICAgIGZvciAoY29uc3QgZCBvZiBnZXRNb3VudGVkT3JQZW5kaW5nRGVwZW5kZW50cyhhLCBhU3RhdGUsIG1vdW50ZWRNYXApKSB7XG4gICAgICBjb25zdCBkU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoc3RvcmUsIGQpO1xuICAgICAgaW52YWxpZGF0ZWRBdG9tcy5zZXQoZCwgZFN0YXRlLm4pO1xuICAgICAgc3RhY2sucHVzaChkKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBCVUlMRElOR19CTE9DS193cml0ZUF0b21TdGF0ZSA9IChzdG9yZSwgYXRvbSwgLi4uYXJncykgPT4ge1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpO1xuICBjb25zdCBjaGFuZ2VkQXRvbXMgPSBidWlsZGluZ0Jsb2Nrc1szXTtcbiAgY29uc3Qgc3RvcmVIb29rcyA9IGJ1aWxkaW5nQmxvY2tzWzZdO1xuICBjb25zdCBhdG9tV3JpdGUgPSBidWlsZGluZ0Jsb2Nrc1s4XTtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTFdO1xuICBjb25zdCBmbHVzaENhbGxiYWNrcyA9IGJ1aWxkaW5nQmxvY2tzWzEyXTtcbiAgY29uc3QgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcyA9IGJ1aWxkaW5nQmxvY2tzWzEzXTtcbiAgY29uc3QgcmVhZEF0b21TdGF0ZSA9IGJ1aWxkaW5nQmxvY2tzWzE0XTtcbiAgY29uc3QgaW52YWxpZGF0ZURlcGVuZGVudHMgPSBidWlsZGluZ0Jsb2Nrc1sxNV07XG4gIGNvbnN0IHdyaXRlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTZdO1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IGJ1aWxkaW5nQmxvY2tzWzE3XTtcbiAgY29uc3Qgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UgPSBidWlsZGluZ0Jsb2Nrc1syMF07XG4gIGxldCBpc1N5bmMgPSB0cnVlO1xuICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoc3RvcmUsIGEpKTtcbiAgY29uc3Qgc2V0dGVyID0gKGEsIC4uLmFyZ3MyKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFTdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShzdG9yZSwgYSk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhID09PSBhdG9tKSB7XG4gICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXRvbSBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgc3RvcmVNdXRhdGlvblNldC5hZGQoc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZFcG9jaE51bWJlciA9IGFTdGF0ZS5uO1xuICAgICAgICBjb25zdCB2ID0gYXJnczJbMF07XG4gICAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKHN0b3JlLCBhLCB2KTtcbiAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoc3RvcmUsIGEpO1xuICAgICAgICBpZiAocHJldkVwb2NoTnVtYmVyICE9PSBhU3RhdGUubikge1xuICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgICAgaW52YWxpZGF0ZURlcGVuZGVudHMoc3RvcmUsIGEpO1xuICAgICAgICAgIChfYSA9IHN0b3JlSG9va3MuYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcmVIb29rcywgYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3cml0ZUF0b21TdGF0ZShzdG9yZSwgYSwgLi4uYXJnczIpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zKHN0b3JlKTtcbiAgICAgICAgZmx1c2hDYWxsYmFja3Moc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXRvbVdyaXRlKHN0b3JlLCBhdG9tLCBnZXR0ZXIsIHNldHRlciwgLi4uYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNTeW5jID0gZmFsc2U7XG4gIH1cbn07XG5jb25zdCBCVUlMRElOR19CTE9DS19tb3VudERlcGVuZGVuY2llcyA9IChzdG9yZSwgYXRvbSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGJ1aWxkaW5nQmxvY2tzID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSk7XG4gIGNvbnN0IG1vdW50ZWRNYXAgPSBidWlsZGluZ0Jsb2Nrc1sxXTtcbiAgY29uc3QgY2hhbmdlZEF0b21zID0gYnVpbGRpbmdCbG9ja3NbM107XG4gIGNvbnN0IHN0b3JlSG9va3MgPSBidWlsZGluZ0Jsb2Nrc1s2XTtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTFdO1xuICBjb25zdCBpbnZhbGlkYXRlRGVwZW5kZW50cyA9IGJ1aWxkaW5nQmxvY2tzWzE1XTtcbiAgY29uc3QgbW91bnRBdG9tID0gYnVpbGRpbmdCbG9ja3NbMThdO1xuICBjb25zdCB1bm1vdW50QXRvbSA9IGJ1aWxkaW5nQmxvY2tzWzE5XTtcbiAgY29uc3QgYXRvbVN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKHN0b3JlLCBhdG9tKTtcbiAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICBpZiAobW91bnRlZCAmJiAhaXNQZW5kaW5nUHJvbWlzZShhdG9tU3RhdGUudikpIHtcbiAgICBmb3IgKGNvbnN0IFthLCBuXSBvZiBhdG9tU3RhdGUuZCkge1xuICAgICAgaWYgKCFtb3VudGVkLmQuaGFzKGEpKSB7XG4gICAgICAgIGNvbnN0IGFTdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShzdG9yZSwgYSk7XG4gICAgICAgIGNvbnN0IGFNb3VudGVkID0gbW91bnRBdG9tKHN0b3JlLCBhKTtcbiAgICAgICAgYU1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICAgIG1vdW50ZWQuZC5hZGQoYSk7XG4gICAgICAgIGlmIChuICE9PSBhU3RhdGUubikge1xuICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgICAgaW52YWxpZGF0ZURlcGVuZGVudHMoc3RvcmUsIGEpO1xuICAgICAgICAgIChfYSA9IHN0b3JlSG9va3MuYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcmVIb29rcywgYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhIG9mIG1vdW50ZWQuZCkge1xuICAgICAgaWYgKCFhdG9tU3RhdGUuZC5oYXMoYSkpIHtcbiAgICAgICAgbW91bnRlZC5kLmRlbGV0ZShhKTtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSB1bm1vdW50QXRvbShzdG9yZSwgYSk7XG4gICAgICAgIGFNb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBhTW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5jb25zdCBCVUlMRElOR19CTE9DS19tb3VudEF0b20gPSAoc3RvcmUsIGF0b20pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpO1xuICBjb25zdCBtb3VudGVkTWFwID0gYnVpbGRpbmdCbG9ja3NbMV07XG4gIGNvbnN0IG1vdW50Q2FsbGJhY2tzID0gYnVpbGRpbmdCbG9ja3NbNF07XG4gIGNvbnN0IHN0b3JlSG9va3MgPSBidWlsZGluZ0Jsb2Nrc1s2XTtcbiAgY29uc3QgYXRvbU9uTW91bnQgPSBidWlsZGluZ0Jsb2Nrc1sxMF07XG4gIGNvbnN0IGVuc3VyZUF0b21TdGF0ZSA9IGJ1aWxkaW5nQmxvY2tzWzExXTtcbiAgY29uc3QgZmx1c2hDYWxsYmFja3MgPSBidWlsZGluZ0Jsb2Nrc1sxMl07XG4gIGNvbnN0IHJlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMgPSBidWlsZGluZ0Jsb2Nrc1sxM107XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSBidWlsZGluZ0Jsb2Nrc1sxNF07XG4gIGNvbnN0IHdyaXRlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTZdO1xuICBjb25zdCBtb3VudEF0b20gPSBidWlsZGluZ0Jsb2Nrc1sxOF07XG4gIGNvbnN0IGF0b21TdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShzdG9yZSwgYXRvbSk7XG4gIGxldCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gIGlmICghbW91bnRlZCkge1xuICAgIHJlYWRBdG9tU3RhdGUoc3RvcmUsIGF0b20pO1xuICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IGFNb3VudGVkID0gbW91bnRBdG9tKHN0b3JlLCBhKTtcbiAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgIH1cbiAgICBtb3VudGVkID0ge1xuICAgICAgbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIGQ6IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKSxcbiAgICAgIHQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIG1vdW50ZWRNYXAuc2V0KGF0b20sIG1vdW50ZWQpO1xuICAgIGlmIChpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICBjb25zdCBwcm9jZXNzT25Nb3VudCA9ICgpID0+IHtcbiAgICAgICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHNldEF0b20gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tU3RhdGUoc3RvcmUsIGF0b20sIC4uLmFyZ3MpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgICByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zKHN0b3JlKTtcbiAgICAgICAgICAgICAgZmx1c2hDYWxsYmFja3Moc3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvblVubW91bnQgPSBhdG9tT25Nb3VudChzdG9yZSwgYXRvbSwgc2V0QXRvbSk7XG4gICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgbW91bnRlZC51ID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudCgpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG1vdW50Q2FsbGJhY2tzLmFkZChwcm9jZXNzT25Nb3VudCk7XG4gICAgfVxuICAgIChfYSA9IHN0b3JlSG9va3MubSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcmVIb29rcywgYXRvbSk7XG4gIH1cbiAgcmV0dXJuIG1vdW50ZWQ7XG59O1xuY29uc3QgQlVJTERJTkdfQkxPQ0tfdW5tb3VudEF0b20gPSAoc3RvcmUsIGF0b20pID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgYnVpbGRpbmdCbG9ja3MgPSBnZXRJbnRlcm5hbEJ1aWxkaW5nQmxvY2tzKHN0b3JlKTtcbiAgY29uc3QgbW91bnRlZE1hcCA9IGJ1aWxkaW5nQmxvY2tzWzFdO1xuICBjb25zdCB1bm1vdW50Q2FsbGJhY2tzID0gYnVpbGRpbmdCbG9ja3NbNV07XG4gIGNvbnN0IHN0b3JlSG9va3MgPSBidWlsZGluZ0Jsb2Nrc1s2XTtcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gYnVpbGRpbmdCbG9ja3NbMTFdO1xuICBjb25zdCB1bm1vdW50QXRvbSA9IGJ1aWxkaW5nQmxvY2tzWzE5XTtcbiAgY29uc3QgYXRvbVN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKHN0b3JlLCBhdG9tKTtcbiAgbGV0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgaWYgKCFtb3VudGVkIHx8IG1vdW50ZWQubC5zaXplKSB7XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH1cbiAgbGV0IGlzRGVwZW5kZW50ID0gZmFsc2U7XG4gIGZvciAoY29uc3QgYSBvZiBtb3VudGVkLnQpIHtcbiAgICBpZiAoKF9hID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kLmhhcyhhdG9tKSkge1xuICAgICAgaXNEZXBlbmRlbnQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghaXNEZXBlbmRlbnQpIHtcbiAgICBpZiAobW91bnRlZC51KSB7XG4gICAgICB1bm1vdW50Q2FsbGJhY2tzLmFkZChtb3VudGVkLnUpO1xuICAgIH1cbiAgICBtb3VudGVkID0gdm9pZCAwO1xuICAgIG1vdW50ZWRNYXAuZGVsZXRlKGF0b20pO1xuICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IGFNb3VudGVkID0gdW5tb3VudEF0b20oc3RvcmUsIGEpO1xuICAgICAgYU1vdW50ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGFNb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICAoX2IgPSBzdG9yZUhvb2tzLnUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHN0b3JlSG9va3MsIGF0b20pO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIG1vdW50ZWQ7XG59O1xuY29uc3QgQlVJTERJTkdfQkxPQ0tfc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UgPSAoc3RvcmUsIGF0b20sIHZhbHVlT3JQcm9taXNlKSA9PiB7XG4gIGNvbnN0IGVuc3VyZUF0b21TdGF0ZSA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpWzExXTtcbiAgY29uc3QgYXRvbVN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKHN0b3JlLCBhdG9tKTtcbiAgY29uc3QgaGFzUHJldlZhbHVlID0gXCJ2XCIgaW4gYXRvbVN0YXRlO1xuICBjb25zdCBwcmV2VmFsdWUgPSBhdG9tU3RhdGUudjtcbiAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgYWRkUGVuZGluZ1Byb21pc2VUb0RlcGVuZGVuY3koXG4gICAgICAgIGF0b20sXG4gICAgICAgIHZhbHVlT3JQcm9taXNlLFxuICAgICAgICBlbnN1cmVBdG9tU3RhdGUoc3RvcmUsIGEpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBhdG9tU3RhdGUudiA9IHZhbHVlT3JQcm9taXNlO1xuICBkZWxldGUgYXRvbVN0YXRlLmU7XG4gIGlmICghaGFzUHJldlZhbHVlIHx8ICFPYmplY3QuaXMocHJldlZhbHVlLCBhdG9tU3RhdGUudikpIHtcbiAgICArK2F0b21TdGF0ZS5uO1xuICAgIGlmIChpc1Byb21pc2VMaWtlKHByZXZWYWx1ZSkpIHtcbiAgICAgIGFib3J0UHJvbWlzZShwcmV2VmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLX3N0b3JlR2V0ID0gKHN0b3JlLCBhdG9tKSA9PiB7XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSBnZXRJbnRlcm5hbEJ1aWxkaW5nQmxvY2tzKHN0b3JlKVsxNF07XG4gIHJldHVybiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShzdG9yZSwgYXRvbSkpO1xufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLX3N0b3JlU2V0ID0gKHN0b3JlLCBhdG9tLCAuLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGJ1aWxkaW5nQmxvY2tzID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSk7XG4gIGNvbnN0IGZsdXNoQ2FsbGJhY2tzID0gYnVpbGRpbmdCbG9ja3NbMTJdO1xuICBjb25zdCByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zID0gYnVpbGRpbmdCbG9ja3NbMTNdO1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IGJ1aWxkaW5nQmxvY2tzWzE2XTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd3JpdGVBdG9tU3RhdGUoc3RvcmUsIGF0b20sIC4uLmFyZ3MpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMoc3RvcmUpO1xuICAgIGZsdXNoQ2FsbGJhY2tzKHN0b3JlKTtcbiAgfVxufTtcbmNvbnN0IEJVSUxESU5HX0JMT0NLX3N0b3JlU3ViID0gKHN0b3JlLCBhdG9tLCBsaXN0ZW5lcikgPT4ge1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpO1xuICBjb25zdCBmbHVzaENhbGxiYWNrcyA9IGJ1aWxkaW5nQmxvY2tzWzEyXTtcbiAgY29uc3QgbW91bnRBdG9tID0gYnVpbGRpbmdCbG9ja3NbMThdO1xuICBjb25zdCB1bm1vdW50QXRvbSA9IGJ1aWxkaW5nQmxvY2tzWzE5XTtcbiAgY29uc3QgbW91bnRlZCA9IG1vdW50QXRvbShzdG9yZSwgYXRvbSk7XG4gIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gIGZsdXNoQ2FsbGJhY2tzKHN0b3JlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB1bm1vdW50QXRvbShzdG9yZSwgYXRvbSk7XG4gICAgZmx1c2hDYWxsYmFja3Moc3RvcmUpO1xuICB9O1xufTtcbmNvbnN0IGJ1aWxkaW5nQmxvY2tNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3MgPSAoc3RvcmUpID0+IHtcbiAgY29uc3QgYnVpbGRpbmdCbG9ja3MgPSBidWlsZGluZ0Jsb2NrTWFwLmdldChzdG9yZSk7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhYnVpbGRpbmdCbG9ja3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlN0b3JlIG11c3QgYmUgY3JlYXRlZCBieSBidWlsZFN0b3JlIHRvIHJlYWQgaXRzIGJ1aWxkaW5nIGJsb2Nrc1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYnVpbGRpbmdCbG9ja3M7XG59O1xuZnVuY3Rpb24gZ2V0QnVpbGRpbmdCbG9ja3Moc3RvcmUpIHtcbiAgY29uc3QgYnVpbGRpbmdCbG9ja3MgPSBnZXRJbnRlcm5hbEJ1aWxkaW5nQmxvY2tzKHN0b3JlKTtcbiAgY29uc3QgZW5oYW5jZUJ1aWxkaW5nQmxvY2tzID0gYnVpbGRpbmdCbG9ja3NbMjRdO1xuICBpZiAoZW5oYW5jZUJ1aWxkaW5nQmxvY2tzKSB7XG4gICAgcmV0dXJuIGVuaGFuY2VCdWlsZGluZ0Jsb2NrcyhidWlsZGluZ0Jsb2Nrcyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWxkaW5nQmxvY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRTdG9yZSguLi5idWlsZEFyZ3MpIHtcbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZ2V0KGF0b20pIHtcbiAgICAgIGNvbnN0IHN0b3JlR2V0ID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSlbMjFdO1xuICAgICAgcmV0dXJuIHN0b3JlR2V0KHN0b3JlLCBhdG9tKTtcbiAgICB9LFxuICAgIHNldChhdG9tLCAuLi5hcmdzKSB7XG4gICAgICBjb25zdCBzdG9yZVNldCA9IGdldEludGVybmFsQnVpbGRpbmdCbG9ja3Moc3RvcmUpWzIyXTtcbiAgICAgIHJldHVybiBzdG9yZVNldChzdG9yZSwgYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzdWIoYXRvbSwgbGlzdGVuZXIpIHtcbiAgICAgIGNvbnN0IHN0b3JlU3ViID0gZ2V0SW50ZXJuYWxCdWlsZGluZ0Jsb2NrcyhzdG9yZSlbMjNdO1xuICAgICAgcmV0dXJuIHN0b3JlU3ViKHN0b3JlLCBhdG9tLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICBjb25zdCBidWlsZGluZ0Jsb2NrcyA9IFtcbiAgICAvLyBzdG9yZSBzdGF0ZVxuICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIC8vIGF0b21TdGF0ZU1hcFxuICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIC8vIG1vdW50ZWRNYXBcbiAgICAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICAvLyBpbnZhbGlkYXRlZEF0b21zXG4gICAgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAvLyBjaGFuZ2VkQXRvbXNcbiAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIC8vIG1vdW50Q2FsbGJhY2tzXG4gICAgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAvLyB1bm1vdW50Q2FsbGJhY2tzXG4gICAge30sXG4gICAgLy8gc3RvcmVIb29rc1xuICAgIC8vIGF0b20gaW50ZXJjZXB0b3JzXG4gICAgQlVJTERJTkdfQkxPQ0tfYXRvbVJlYWQsXG4gICAgQlVJTERJTkdfQkxPQ0tfYXRvbVdyaXRlLFxuICAgIEJVSUxESU5HX0JMT0NLX2F0b21PbkluaXQsXG4gICAgQlVJTERJTkdfQkxPQ0tfYXRvbU9uTW91bnQsXG4gICAgLy8gYnVpbGRpbmctYmxvY2sgZnVuY3Rpb25zXG4gICAgQlVJTERJTkdfQkxPQ0tfZW5zdXJlQXRvbVN0YXRlLFxuICAgIEJVSUxESU5HX0JMT0NLX2ZsdXNoQ2FsbGJhY2tzLFxuICAgIEJVSUxESU5HX0JMT0NLX3JlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMsXG4gICAgQlVJTERJTkdfQkxPQ0tfcmVhZEF0b21TdGF0ZSxcbiAgICBCVUlMRElOR19CTE9DS19pbnZhbGlkYXRlRGVwZW5kZW50cyxcbiAgICBCVUlMRElOR19CTE9DS193cml0ZUF0b21TdGF0ZSxcbiAgICBCVUlMRElOR19CTE9DS19tb3VudERlcGVuZGVuY2llcyxcbiAgICBCVUlMRElOR19CTE9DS19tb3VudEF0b20sXG4gICAgQlVJTERJTkdfQkxPQ0tfdW5tb3VudEF0b20sXG4gICAgQlVJTERJTkdfQkxPQ0tfc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UsXG4gICAgQlVJTERJTkdfQkxPQ0tfc3RvcmVHZXQsXG4gICAgQlVJTERJTkdfQkxPQ0tfc3RvcmVTZXQsXG4gICAgQlVJTERJTkdfQkxPQ0tfc3RvcmVTdWIsXG4gICAgdm9pZCAwXG4gIF0ubWFwKChmbiwgaSkgPT4gYnVpbGRBcmdzW2ldIHx8IGZuKTtcbiAgYnVpbGRpbmdCbG9ja01hcC5zZXQoc3RvcmUsIE9iamVjdC5mcmVlemUoYnVpbGRpbmdCbG9ja3MpKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgeyBhYm9ydFByb21pc2UgYXMgSU5URVJOQUxfYWJvcnRQcm9taXNlLCBhZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeSBhcyBJTlRFUk5BTF9hZGRQZW5kaW5nUHJvbWlzZVRvRGVwZW5kZW5jeSwgYnVpbGRTdG9yZSBhcyBJTlRFUk5BTF9idWlsZFN0b3JlUmV2MiwgZ2V0QnVpbGRpbmdCbG9ja3MgYXMgSU5URVJOQUxfZ2V0QnVpbGRpbmdCbG9ja3NSZXYyLCBnZXRNb3VudGVkT3JQZW5kaW5nRGVwZW5kZW50cyBhcyBJTlRFUk5BTF9nZXRNb3VudGVkT3JQZW5kaW5nRGVwZW5kZW50cywgaGFzSW5pdGlhbFZhbHVlIGFzIElOVEVSTkFMX2hhc0luaXRpYWxWYWx1ZSwgaW5pdGlhbGl6ZVN0b3JlSG9va3MgYXMgSU5URVJOQUxfaW5pdGlhbGl6ZVN0b3JlSG9va3NSZXYyLCBpc0FjdHVhbGx5V3JpdGFibGVBdG9tIGFzIElOVEVSTkFMX2lzQWN0dWFsbHlXcml0YWJsZUF0b20sIGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQgYXMgSU5URVJOQUxfaXNBdG9tU3RhdGVJbml0aWFsaXplZCwgaXNQZW5kaW5nUHJvbWlzZSBhcyBJTlRFUk5BTF9pc1BlbmRpbmdQcm9taXNlLCBpc1Byb21pc2VMaWtlIGFzIElOVEVSTkFMX2lzUHJvbWlzZUxpa2UsIHByb21pc2VTdGF0ZU1hcCBhcyBJTlRFUk5BTF9wcm9taXNlU3RhdGVNYXAsIHJlZ2lzdGVyQWJvcnRIYW5kbGVyIGFzIElOVEVSTkFMX3JlZ2lzdGVyQWJvcnRIYW5kbGVyLCByZXR1cm5BdG9tVmFsdWUgYXMgSU5URVJOQUxfcmV0dXJuQXRvbVZhbHVlIH07XG4iXSwibmFtZXMiOlsiaGFzSW5pdGlhbFZhbHVlIiwiYXRvbSIsImlzQWN0dWFsbHlXcml0YWJsZUF0b20iLCJ3cml0ZSIsImlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQiLCJhdG9tU3RhdGUiLCJyZXR1cm5BdG9tVmFsdWUiLCJlIiwiZW52IiwiTU9ERSIsIkVycm9yIiwidiIsInByb21pc2VTdGF0ZU1hcCIsIldlYWtNYXAiLCJpc1BlbmRpbmdQcm9taXNlIiwidmFsdWUiLCJfYSIsImlzUHJvbWlzZUxpa2UiLCJnZXQiLCJhYm9ydFByb21pc2UiLCJwcm9taXNlIiwicHJvbWlzZVN0YXRlIiwiZm9yRWFjaCIsImZuIiwicmVnaXN0ZXJBYm9ydEhhbmRsZXIiLCJhYm9ydEhhbmRsZXIiLCJTZXQiLCJzZXQiLCJzZXR0bGUiLCJ0aGVuIiwiYWRkIiwicCIsImFkZFBlbmRpbmdQcm9taXNlVG9EZXBlbmRlbmN5IiwiZGVwZW5kZW5jeUF0b21TdGF0ZSIsImhhcyIsImNsZWFudXAiLCJkZWxldGUiLCJnZXRNb3VudGVkT3JQZW5kaW5nRGVwZW5kZW50cyIsIm1vdW50ZWRNYXAiLCJkZXBlbmRlbnRzIiwiYSIsInQiLCJhdG9tV2l0aFBlbmRpbmdQcm9taXNlIiwiY3JlYXRlU3RvcmVIb29rIiwiY2FsbGJhY2tzIiwibm90aWZ5IiwiY3JlYXRlU3RvcmVIb29rRm9yQXRvbXMiLCJhbGwiLCJfYiIsImtleSIsImZucyIsInNpemUiLCJpbml0aWFsaXplU3RvcmVIb29rcyIsInN0b3JlSG9va3MiLCJpIiwiciIsImMiLCJtIiwidSIsImYiLCJCVUlMRElOR19CTE9DS19hdG9tUmVhZCIsIl9zdG9yZSIsInBhcmFtcyIsInJlYWQiLCJCVUlMRElOR19CTE9DS19hdG9tV3JpdGUiLCJCVUlMRElOR19CTE9DS19hdG9tT25Jbml0Iiwic3RvcmUiLCJJTlRFUk5BTF9vbkluaXQiLCJ1bnN0YWJsZV9vbkluaXQiLCJjb25zb2xlIiwid2FybiIsIkJVSUxESU5HX0JMT0NLX2F0b21Pbk1vdW50Iiwic2V0QXRvbSIsIm9uTW91bnQiLCJjYWxsIiwiQlVJTERJTkdfQkxPQ0tfZW5zdXJlQXRvbVN0YXRlIiwiYnVpbGRpbmdCbG9ja3MiLCJnZXRJbnRlcm5hbEJ1aWxkaW5nQmxvY2tzIiwiYXRvbVN0YXRlTWFwIiwiYXRvbU9uSW5pdCIsImQiLCJNYXAiLCJuIiwiQlVJTERJTkdfQkxPQ0tfZmx1c2hDYWxsYmFja3MiLCJjaGFuZ2VkQXRvbXMiLCJtb3VudENhbGxiYWNrcyIsInVubW91bnRDYWxsYmFja3MiLCJyZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zIiwiZXJyb3JzIiwicHVzaCIsImJpbmQiLCJsIiwiY2xlYXIiLCJsZW5ndGgiLCJBZ2dyZWdhdGVFcnJvciIsIkJVSUxESU5HX0JMT0NLX3JlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMiLCJpbnZhbGlkYXRlZEF0b21zIiwiZW5zdXJlQXRvbVN0YXRlIiwicmVhZEF0b21TdGF0ZSIsIm1vdW50RGVwZW5kZW5jaWVzIiwidG9wU29ydGVkUmV2ZXJzZWQiLCJ2aXNpdGluZyIsIldlYWtTZXQiLCJ2aXNpdGVkIiwic3RhY2siLCJBcnJheSIsImZyb20iLCJhU3RhdGUiLCJwb3AiLCJoYXNDaGFuZ2VkRGVwcyIsImRlcCIsImtleXMiLCJzdG9yZU11dGF0aW9uU2V0IiwiQlVJTERJTkdfQkxPQ0tfcmVhZEF0b21TdGF0ZSIsImF0b21SZWFkIiwiZmx1c2hDYWxsYmFja3MiLCJ3cml0ZUF0b21TdGF0ZSIsInNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlIiwiaXNTeW5jIiwibW91bnREZXBlbmRlbmNpZXNJZkFzeW5jIiwiZ2V0dGVyIiwiX2EyIiwiYVN0YXRlMiIsImluaXQiLCJjb250cm9sbGVyIiwic2V0U2VsZiIsIm9wdGlvbnMiLCJzaWduYWwiLCJBYm9ydENvbnRyb2xsZXIiLCJhcmdzIiwicHJldkVwb2NoTnVtYmVyIiwidmFsdWVPclByb21pc2UiLCJhYm9ydCIsImVycm9yIiwiQlVJTERJTkdfQkxPQ0tfaW52YWxpZGF0ZURlcGVuZGVudHMiLCJkU3RhdGUiLCJCVUlMRElOR19CTE9DS193cml0ZUF0b21TdGF0ZSIsImF0b21Xcml0ZSIsImludmFsaWRhdGVEZXBlbmRlbnRzIiwic2V0dGVyIiwiYXJnczIiLCJCVUlMRElOR19CTE9DS19tb3VudERlcGVuZGVuY2llcyIsIm1vdW50QXRvbSIsInVubW91bnRBdG9tIiwibW91bnRlZCIsImFNb3VudGVkIiwiQlVJTERJTkdfQkxPQ0tfbW91bnRBdG9tIiwiYXRvbU9uTW91bnQiLCJwcm9jZXNzT25Nb3VudCIsIm9uVW5tb3VudCIsIkJVSUxESU5HX0JMT0NLX3VubW91bnRBdG9tIiwiaXNEZXBlbmRlbnQiLCJCVUlMRElOR19CTE9DS19zZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSIsImhhc1ByZXZWYWx1ZSIsInByZXZWYWx1ZSIsIk9iamVjdCIsImlzIiwiQlVJTERJTkdfQkxPQ0tfc3RvcmVHZXQiLCJCVUlMRElOR19CTE9DS19zdG9yZVNldCIsIkJVSUxESU5HX0JMT0NLX3N0b3JlU3ViIiwibGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJidWlsZGluZ0Jsb2NrTWFwIiwiZ2V0QnVpbGRpbmdCbG9ja3MiLCJlbmhhbmNlQnVpbGRpbmdCbG9ja3MiLCJidWlsZFN0b3JlIiwiYnVpbGRBcmdzIiwic3RvcmVHZXQiLCJzdG9yZVNldCIsInN1YiIsInN0b3JlU3ViIiwibWFwIiwiZnJlZXplIiwiSU5URVJOQUxfYWJvcnRQcm9taXNlIiwiSU5URVJOQUxfYWRkUGVuZGluZ1Byb21pc2VUb0RlcGVuZGVuY3kiLCJJTlRFUk5BTF9idWlsZFN0b3JlUmV2MiIsIklOVEVSTkFMX2dldEJ1aWxkaW5nQmxvY2tzUmV2MiIsIklOVEVSTkFMX2dldE1vdW50ZWRPclBlbmRpbmdEZXBlbmRlbnRzIiwiSU5URVJOQUxfaGFzSW5pdGlhbFZhbHVlIiwiSU5URVJOQUxfaW5pdGlhbGl6ZVN0b3JlSG9va3NSZXYyIiwiSU5URVJOQUxfaXNBY3R1YWxseVdyaXRhYmxlQXRvbSIsIklOVEVSTkFMX2lzQXRvbVN0YXRlSW5pdGlhbGl6ZWQiLCJJTlRFUk5BTF9pc1BlbmRpbmdQcm9taXNlIiwiSU5URVJOQUxfaXNQcm9taXNlTGlrZSIsIklOVEVSTkFMX3Byb21pc2VTdGF0ZU1hcCIsIklOVEVSTkFMX3JlZ2lzdGVyQWJvcnRIYW5kbGVyIiwiSU5URVJOQUxfcmV0dXJuQXRvbVZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla/internals.mjs\n");

/***/ })

};
;